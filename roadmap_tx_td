
ROADMAP И ТЕХНИЧЕСКИЙ ДОЛГ
Назначение: Этот раздел отслеживает задачи, которые не являются багами, но важны для будущего развития и здоровья проекта.
1. Обновление ключевых зависимостей:
Контекст: На момент анализа (28.09.2025) основной стек проекта (Next.js, React, NextAuth.js) отстает на одно мажорное поколение от последних стабильных версий. Это сделано для обеспечения стабильности, но создает технический долг.
Задачи:
Next.js: Спланировать миграцию с v14 на v15.
Цель: Улучшения производительности (Turbopack), доступ к новому API.
React: Спланировать миграцию с v18 на v19 (выполнять совместно с обновлением Next.js).
Цель: Использование новых фич (React Actions, useOptimistic), которые могут значительно упростить код.
NextAuth.js: Спланировать миграцию с v4 на v5.
Цель: Упрощение архитектуры аутентификации, нативная поддержка App Router.
Статус: Отложено. Обновление требует значительного рефакторинга и должно быть выполнено как отдельная, спланированная итерация. Текущая разработка ведется на стеке v14/v18/v4.
2. Улучшения на основе next.config.mjs:
Контекст: Текущая конфигурация Next.js функциональна, но может быть улучшена в областях безопасности, производительности и строгости сборки.
Задачи:
[Безопасность] Внедрить Content Security Policy (CSP): Добавить в секцию headers более современную и строгую политику CSP для усиленной защиты от XSS-атак.
[Производительность] Активировать images.remotePatterns: При переходе на внешнее хранилище изображений (CDN, S3), необходимо раскомментировать и настроить этот блок для включения нативной оптимизации изображений Next.js.
[CI/CD] Повысить строгость сборки: В будущем рассмотреть установку eslint.ignoreDuringBuilds: false, чтобы наличие ошибок линтинга приводило к ошибке сборки, тем самым повышая качество кода в основной ветке.
Статус: Отложено.
3. Улучшения Design System на основе tailwind.config.ts:
Контекст: Текущая конфигурация Tailwind задает мощную и хорошо структурированную дизайн-систему. Однако, ее можно расширить для повышения консистентности и удобства разработки.
Задачи:
[Design System] Расширить систему типографики: Кастомный плагин сейчас генерирует только классы для размера, высоты строки и межбуквенного расстояния. Необходимо расширить его, чтобы он также включал font-family и font-weight. Это позволит создавать полностью готовые классы типографики (например, .text-heading-h1, .text-body-large-bold) и еще сильнее сократить количество классов в JSX.
[Design System] Добавить систему отступов (spacing): В текущем конфиге не определены кастомные значения для отступов. Это может привести к использованию "магических чисел" и хаотичных значений (mt-3, p-5, pb-7). Необходимо определить и добавить в секцию theme.extend.spacing ограниченный набор именованных значений (например, s: '4px', m: '8px', l: '16px'), чтобы сделать верстку более предсказуемой и консистентной.
[Рефакторинг] Проанализировать кастомный breakpoint: Проверить использование брейкпоинта kyanchir-lg. Если он используется в одном-двух местах, возможно, стоит заменить его на "одноразовый" медиа-запрос прямо в компоненте, чтобы не усложнять глобальную конфигурацию. Если же он используется системно, оставить как есть.
Статус: Отложено.
4. Улучшения конфигурации TypeScript на основе tsconfig.json:
Контекст: Конфигурация использует строгий режим (strict: true), что является лучшей практикой. Однако, присутствует незначительная ошибка и есть возможность для дальнейшего ужесточения правил для повышения качества кода.
Задачи:
[Maintenance] Исправить опечатку в include: Удалить некорректную запись "src/app/api/auth/verify-code/route.ts.дtkk" из массива include. Это необходимо для поддержания чистоты и корректности конфигурационного файла.
[Code Quality] Включить дополнительные флаги strict-режима: Рассмотреть возможность добавления в compilerOptions флагов "noUnusedLocals": true и "noUnusedParameters": true. Это позволит автоматически выявлять неиспользуемые переменные и параметры функций, что способствует уменьшению "мертвого" кода и повышению его чистоты.
Статус: Отложено.
5. Улучшения конфигурации Prettier на основе prettier.config.js:
Контекст: Текущая конфигурация Prettier является полной, современной и соответствует лучшим практикам. Она обеспечивает высокий уровень консистентности кода и идеально интегрирована с Tailwind CSS.
Задачи: На данный момент улучшений не требуется. Конфигурация полностью решает свою задачу.
Статус: Завершено / Не требуется.
6. Улучшения конфигурации ESLint на основе eslint.config.mjs:
Контекст: Текущая конфигурация является современной ("Flat Config") и эффективной, так как использует официальные наборы правил от Next.js. Это обеспечивает высокий базовый уровень качества кода. Однако, можно добавить правила для улучшения консистентности и предотвращения конфликтов между инструментами.
Задачи:
[Интеграция] Добавить eslint-config-prettier: Установить и добавить в конец массива конфигурации eslint-config-prettier. Это критически важно для того, чтобы правила форматирования ESLint не конфликтовали с Prettier. Prettier должен быть единственным ответственным за форматирование.
[Code Quality] Внедрить сортировку импортов: Рассмотреть добавление плагина для строгой сортировки импортов (например, eslint-plugin-import или eslint-plugin-simple-import-sort). Это повысит читаемость и консистентность файлов по мере роста проекта.
Статус: Отложено.
7. Улучшения конфигурации Vercel на основе vercel.json:
Контекст: Проект использует нативную функцию Vercel Cron Jobs для автоматизации, что является правильным подходом для серверлесс-архитектуры. Однако, текущая реализация содержит критическую уязвимость безопасности.
Задачи:
[Security] Устранить уязвимость с захардкоженным секретом: Это высокоприоритетная задача. Необходимо удалить секрет (cron_secret) из файла vercel.json и вынести его в переменные окружения на платформе Vercel.
Шаг 1: В vercel.json заменить ?cron_secret=... на ?cron_secret=${CRON_SECRET}.
Шаг 2: В настройках проекта на Vercel создать переменную окружения CRON_SECRET и поместить в нее секретное значение.
[Optimization] Проанализировать расписание cron-задачи: Расписание "0 0 * * *" (полночь UTC) является популярным и может попадать на пиковые часы нагрузки на внешние API (например, "МойСклад"). Рассмотреть возможность смещения времени выполнения на менее загруженные часы (например, "15 4 * * *" - 4:15 UTC) для повышения надежности.
Статус: Отложено.
8. Улучшения конфигурации для tsconfig.seed.json:
Контекст: Данный файл предоставляет изолированную и корректную конфигурацию TypeScript специально для выполнения seed-скрипта в среде Node.js. Он полностью решает свою задачу, обеспечивая надежный запуск npm run db:seed.
Задачи: На данный момент улучшений не требуется. Конфигурация является полной и правильной.
Статус: Завершено / Не требуется.
9. Улучшения интеграции с Telegram Mini App на основе telegram.d.ts:
Контекст: Текущий файл telegram.d.ts корректно решает задачу типизации для уже используемой части Telegram Mini App API. Однако, он является неполным и требует ручной поддержки при добавлении нового функционала (например, MainButton, HapticFeedback, initData и т.д.).
Задачи:
[Refactoring] Заменить ручные декларации на готовый пакет типов: Установить официальный или общепринятый пакет с типами для Telegram Mini App API (например, @twa-dev/types). Это обеспечит полные, точные и автоматически обновляемые типы для всего API, что значительно ускорит будущую разработку и снизит вероятность ошибок.
Статус: Отложено.
10. Улучшения конфигурации PostCSS на основе postcss.config.mjs:
Контекст: Текущая конфигурация PostCSS является канонической для проекта на Next.js + Tailwind CSS. Она корректно выполняет две ключевые задачи: обработку утилит Tailwind и добавление префиксов для кросс-браузерной совместимости.
Задачи: На данный момент улучшений не требуется. Конфигурация является полной и оптимальной для текущего стека.
Статус: Завершено / Не требуется.
11. Улучшения конфигурации Git на основе .gitignore:
Контекст: Файл .gitignore корректно настроен для исключения секретов, зависимостей и артефактов сборки из репозитория. Однако, он содержит правило, которое может быть устаревшим.
Задачи:
[Maintenance] Проверить актуальность правила /src/generated/prisma: Это правило игнорирует кастомную директорию для сгенерированного Prisma-клиента. Необходимо проверить файл prisma/schema.prisma и определить, используется ли до сих пор кастомный output для генератора клиента.
Если используется: Задача не требуется.
Если не используется (клиент генерируется в node_modules): Удалить строку /src/generated/prisma из .gitignore, чтобы конфигурация отражала актуальное состояние проекта.
Статус: Отложено.
12. Улучшения в управлении секретами на основе .env.local:
Контекст: Файл .env.local является центральным хранилищем для локальной разработки и подтверждает использование множества внешних сервисов. Правильное управление этими секретами в разных окружениях (development, preview, production) является критически важной задачей для безопасности и стабильности проекта.
Задачи:
[Operations/Security] Аудит переменных окружения на Vercel: Провести полную сверку всех переменных из .env.local с переменными, настроенными в Vercel. Необходимо убедиться, что для production и preview окружений существуют все необходимые ключи и они имеют актуальные значения.
[Security] Внедрить политику ротации секретов: Разработать и задокументировать процедуру периодической смены критически важных секретов (как минимум AUTH_SECRET, EMAIL_SERVER_PASSWORD, MOYSKLAD_API_TOKEN, ENCRYPTION_KEY).
[Refactoring] Стандартизировать именование переменных: Рассмотреть возможность рефакторинга имен переменных для большей консистентности. Например, переименовать TELEGRAM_BOT_TOKEN в TELEGRAM_CLIENT_BOT_TOKEN и TELEGRAM_SUPPORT_BOT_TOKEN в TELEGRAM_ADMIN_BOT_TOKEN, чтобы их назначение было абсолютно очевидным.
Статус: Отложено.
13. Очистка устаревших артефактов:
Контекст: В корневой директории проекта присутствуют файлы, которые являлись частью процесса разработки, но на данный момент утратили свою актуальность и являются "шумом".
Задачи:
[Cleanup] Удалить директорию /data: Полностью удалить папку /data вместе с файлом products.csv, так как он больше не используется для наполнения БД.
[Cleanup] Удалить текстовые слепки структуры: Удалить файлы project_tree.txt и project-structure.txt. Их роль теперь выполняет "Конституция проекта".
Статус: Отложено. Выполнить в рамках единой задачи по очистке проекта после завершения полного анализа.
14. Архитектурная трансформация данных (на основе schema.prisma):
Контекст: Текущая монолитная схема данных является хорошо спроектированной, но представляет собой стратегический риск для масштабируемости, производительности и отказоустойчивости проекта. При росте аудитории она станет "узким местом", что может привести к замедлению работы, ошибкам и потере данных в критических операциях (например, при оформлении заказа).
Главная цель: Трансформировать монолитную базу данных в мульти-базовую, сервис-ориентированную архитектуру, где каждый логический домен изолирован.
Задачи:
[Architecture/High Priority] Разделение баз данных: Это критически важная задача для обеспечения масштабируемости.
План: Вместо одной DATABASE_URL использовать несколько отдельных баз данных PostgreSQL (например, на том же Neon можно создать несколько проектов): USERS_DB, PRODUCTS_DB, ORDERS_DB, SUPPORT_DB.
Цель: Изоляция нагрузки (высокая активность в каталоге не замедлит оформление заказов), независимое резервное копирование и восстановление, повышение отказоустойчивости.
[Refactoring] Разделение schema.prisma на доменные файлы: После перехода на мульти-базовую архитектуру, повторно реализовать разделение монолитной schema.prisma на несколько файлов (users.prisma, products.prisma и т.д.), настроив для каждого свой datasource. Это упростит разработку и управление схемой.
[Reliability] Внедрение транзакций для критических операций: Для предотвращения частичного выполнения операций (как в твоем примере с оплатой без создания заказа) необходимо обернуть всю связанную бизнес-логику в prisma.$transaction.
Пример: Операция "создать заказ" должна включать: создание записи в Order, создание OrderItem, обновление stock в ProductSize и отправку запроса в "МойСклад". Все эти шаги должны либо выполниться успешно, либо полностью откатиться в случае любой ошибки.
[Security/Operations] Разработать промышленную систему бэкапов:
•		•	План: Создать автоматизированный процесс (через GitHub Actions или другой шедулер), который по расписанию делает pg_dump каждой отдельной базы данных, шифрует дамп и загружает его в надежное S3-совместимое хранилище (Vercel Blob, AWS S3 и т.д.). Уведомления о статусе бэкапа должны приходить в админ-бота.
Статус: Отложено. Это — генеральный план для следующего большого этапа рефакторинга.
15. Архитектурный рефакторинг статических ассетов (на основе анализа /public):
Контекст: Директория /public в её текущем состоянии содержит устаревшие файлы и реализует архитектурный антипаттерн, сохраняя загружаемые пользователем файлы в локальную файловую систему. На серверлесс-платформах (как Vercel) это приведёт к гарантированной потере всех загруженных изображений при следующем деплое.
Задачи:
[Architecture/High Priority] Внедрить внешнее S3-совместимое хранилище: Это критически важная задача для обеспечения целостности данных.
План: Рефакторить логику загрузки изображений. Вместо сохранения файлов на локальный диск, они должны напрямую загружаться в облачное хранилище (например, Vercel Blob, AWS S3, Cloudflare R2). В базу данных должен сохраняться постоянный URL из этого хранилища.
[Cleanup] Полная очистка директории /public: После внедрения облачного хранилища необходимо провести полную очистку.
План: Удалить все устаревшие изображения-заглушки (Фото - *.png, placeholder.png) и директории (/images, /uploads), которые больше не используются.
[Refactoring] Создать новую структуру для статики: Сформировать чистую и логичную структуру для действительно статических ассетов, которые являются частью приложения, а не пользовательским контентом.
Пример: /public/icons/ (для favicon, иконок PWA), /public/brand/ (для логотипов).
Статус: Отложено.
16. Улучшения конфигурации Middleware на основе src/middleware.ts:
Контекст: Текущая реализация middleware является чистой, эффективной и следует лучшей практике "Диспетчер, а не Охранник". Однако, она содержит захардкоженные доменные имена, что снижает ее гибкость и переносимость между различными окружениями (например, staging, development).
Задачи:
[Refactoring] Вынести захардкоженные доменные имена в переменные окружения:
План:
В файле .env заменить константы на переменные окружения, например: MAIN_DOMAIN="kyanchir.ru" и ADMIN_DOMAIN="admin.kyanchir.ru".
В файле middleware.ts заменить захардкоженные константы на process.env.MAIN_DOMAIN и process.env.ADMIN_DOMAIN.
Цель: Это позволит развертывать приложение в любом окружении (например, на тестовом домене staging.kyanchir.ru) без необходимости изменять исходный код.
Статус: Отложено.
17. Улучшения корневого Layout на основе src/app/layout.tsx:
Контекст: Текущий RootLayout является чистым и минималистичным "скелетом" приложения, что является правильной архитектурой. Он закладывает основу для PWA и Telegram Mini App, но не реализует динамическое управление метаданными и полный функционал PWA.
Задачи:
[SEO/UX] Внедрить динамическую генерацию метаданных: На данный момент title и description являются статичными. Необходимо использовать функцию Next.js generateMetadata в дочерних layout'ах и на страницах для динамического формирования метатегов (например, "Название Товара | Kyanchir").
[PWA] Реализовать полноценный Web App Manifest: Создать и подключить в <head> файл manifest.webmanifest. В нем нужно определить иконки приложения для разных разрешений, цвета темы, стартовый URL и другие параметры для корректной установки приложения на главный экран.
[PWA/Future] Спланировать внедрение Service Worker: Для обеспечения оффлайн-доступа и повышения производительности, необходимо спланировать и реализовать стратегию кэширования с помощью Service Worker.
Статус: Отложено.
18. Унификация Design System на основе globals.css:
Контекст: Анализ файла globals.css выявил критическую архитектурную проблему: существование двух конкурирующих систем для управления типографикой. Одна система — это глобальные стили для тегов (h1, h2 и т.д.) в globals.css. Вторая — это кастомный плагин в tailwind.config.ts, генерирующий утилитарные классы (.text-h1, .text-h2). Это приводит к неконсистентности, усложняет поддержку и нарушает принцип "единого источника правды".
Задачи:
[Architecture/High Priority] Унифицировать систему типографики: Это высокоприоритетная задача для обеспечения консистентности и чистоты кода.
План:
Полностью удалить глобальные стили для тегов h1, h2, h3 и т.д. из файла globals.css.
Утвердить tailwind.config.ts и его кастомный плагин как единственный источник правды для всех стилей типографики.
Провести глобальный рефакторинг проекта, заменив использование "голых" тегов заголовков на компоненты с явным применением утилитарных классов (например, <h1 className="text-h1">).
[Refactoring] Централизовать Design Tokens: Провести аудит CSS-переменных в :root и цветов в tailwind.config.ts. Убедиться, что tailwind.config.ts является единственным источником определения цветов, а globals.css только использует их через var(), избегая дублирования.
Статус: Отложено.
19. Улучшения конфигурации шрифтов на основе src/app/fonts.ts:
Контекст: Текущая конфигурация шрифтов является образцовой. Она использует встроенную в Next.js систему оптимизации (next/font), семантически разделяет шрифты и корректно интегрируется с Tailwind CSS через CSS-переменные.
Задачи: На данный момент улучшений не требуется. Конфигурация является полной, производительной и соответствует лучшим практикам.
Статус: Завершено / Не требуется.
20. Улучшения Layout'а клиентской части на основе (site)/layout.tsx:
Контекст: Данный layout корректно использует Route Group для изоляции UI клиентской части. Однако, он помечен директивой 'use client' на самом верхнем уровне. Это превращает все страницы публичного сайта в клиентские компоненты, что потенциально нивелирует одно из главных преимуществ App Router — рендеринг на сервере по умолчанию.
Задачи:
[Performance/Architecture] Оптимизировать границу "use client":
План: Провести рефакторинг, убрав 'use client' из этого layout-файла. Вместо этого, директива 'use client' должна быть перемещена "вглубь" дерева компонентов — непосредственно в те компоненты внутри <AppCore>, которые действительно требуют интерактивности (например, Header.tsx, FloatingMenuOverlay.tsx).
Цель: Позволить страницам, которые могут быть отрендерены на сервере (например, страницы каталога, карточки товаров), оставаться серверными компонентами. Это уменьшит размер клиентского JavaScript-бандла, улучшит начальную скорость загрузки и SEO.
Статус: Отложено. Это важный архитектурный рефакторинг, который следует выполнить для повышения производительности.
21. Улучшения главной страницы на основе (site)/page.tsx:
Контекст: Текущая реализация главной страницы является хорошим примером серверного компонента, но содержит несколько архитектурных решений, которые необходимо оптимизировать для production-среды: принудительное динамическое выполнение и захардкоженные бизнес-правила.
Задачи:
[Performance/High Priority] Заменить 'force-dynamic' на стратегию инкрементальной статической регенерации (ISR):
План: Удалить export const dynamic = 'force-dynamic'. Вместо этого, настроить revalidation на уровне страницы, например: export const revalidate = 300; (пересоздавать страницу не чаще, чем раз в 5 минут).
Цель: Радикально снизить нагрузку на базу данных и сервер, отдавая большинству пользователей кэшированную версию страницы. Это критически важно для производительности при большом трафике.
[Reliability] Сделать фильтрацию по статусу 'PUBLISHED' зависимой от окружения:
План: Заменить закомментированное правило на условное, которое будет активно только в production-окружении: where: { status: process.env.NODE_ENV === 'production' ? 'PUBLISHED' : undefined }.
Цель: Устранить риск случайной "утечки" неопубликованных товаров на продакшен-сайт, если разработчик забудет раскомментировать строку.
[Refactoring] Устранить "магическую строку" для пресета фильтра:
План: Вынести 'main-store-filter' в константу или переменную окружения и импортировать ее, чтобы избежать рассинхронизации, если имя пресета изменится в базе данных.
Цель: Повысить надежность и поддерживаемость кода.
Статус: Отложено.
22. Улучшения UI индикатора загрузки на основе (site)/loading.tsx:
Контекст: Компонент loading.tsx эффективно использует возможности Next.js, но его реализация содержит жесткую связь с архитектурой хедера через захардкоженные "магические числа" (z-index). Это делает UI хрупким: любое изменение z-index хедера потребует неочевидного изменения в этом файле, что легко пропустить.
Задачи:
[Refactoring/High Priority] Централизовать управление z-index в Design System:
План:
В файле tailwind.config.ts, в секции theme.extend, добавить новый объект zIndex с семантическими ключами (например, header: '150', headerHome: '152', loadingOverlay: '155').
Провести рефакторинг loading.tsx и всех компонентов хедера, заменив захардкоженные классы (z-[155]) на семантические (z-loadingOverlay).
Цель: Устранить "магические числа" и сделать tailwind.config.ts единственным источником правды для управления слоями z-index, что повысит надежность и поддерживаемость UI.
[Architecture] Декомпозировать логику z-index: Рассмотреть возможность вынести логику выбора z-index из компонента loading.tsx на более высокий уровень (например, в AppCore.tsx), откуда она могла бы передаваться через props или React Context. Это сделает loading.tsx более "глупым" и переиспользуемым компонентом.
Статус: Отложено.
23. Улучшения флоу верификации email на основе (site)/verify-email/page.tsx:
Контекст: Текущая реализация флоу верификации является функциональной и безопасной, используя классический подход с fetch к API-маршруту. Однако, ее можно модернизировать для более тесной интеграции с современными паттернами App Router и повышения гибкости.
Задачи:
[Refactoring/Architecture] Мигрировать с API Route на Server Action:
План: Заменить текущий fetch запрос на вызов Server Action. Для этого нужно создать файл actions.ts рядом со страницей, определить в нем асинхронную функцию verifyTokenAction и вызывать ее из useEffect внутри useTransition.
Цель: Уменьшить количество boilerplate-кода (не нужно создавать отдельный API-маршрут), повысить типобезопасность и полностью соответствовать современной архитектуре Next.js.
[UX/Refactoring] Сделать редирект более гибким:
План: Модифицировать логику генерации ссылки для верификации так, чтобы она включала redirect_url в качестве параметра. Страница верификации должна считывать этот параметр и, в случае успеха, перенаправлять пользователя по указанному URL, а не жестко на /profile.
Цель: Повысить гибкость системы. Например, если пользователь начал оформлять заказ и ему потребовалось подтвердить email, после верификации он должен вернуться в корзину, а не в профиль.
Статус: Отложено.
24. Улучшения формы поддержки на основе (site)/support/page.tsx:
Контекст: Форма поддержки является качественной и полнофункциональной реализацией с использованием классического паттерна fetch к API Route. Ее можно модернизировать для соответствия новейшим паттернам Next.js и улучшить UX.
Задачи:
[Refactoring/Architecture] Мигрировать с API Route на Server Action:
План: Аналогично странице верификации, заменить fetch на вызов Server Action. Это позволит объединить клиентскую и серверную логику в одном месте (через файл actions.ts), улучшить обработку состояний (pending через useTransition) и избавиться от необходимости создавать отдельный API-маршрут.
Цель: Упрощение кода, повышение типобезопасности, соответствие современной архитектуре Next.js.
[UX] Автозаполнение полей для авторизованных пользователей:
План: Модифицировать компонент так, чтобы он получал данные о сессии пользователя (например, через хук useSession). Если пользователь авторизован, поля "Имя" и "Email" должны быть автоматически предзаполнены и, возможно, сделаны нередактируемыми.
Цель: Улучшить UX, избавляя постоянных клиентов от необходимости вводить свои данные повторно.
[Validation] Внедрить Zod для клиентской валидации:
План: Использовать ту же схему Zod, которая (предположительно) используется на бэкенде, для валидации на клиенте. Это позволит реализовать более сложную и консистентную валидацию (например, проверку формата email) перед отправкой формы.
Цель: Улучшить UX, предоставляя более детальную обратную связь по ошибкам, и следовать принципу DRY, используя одну и ту же схему валидации на клиенте и сервере.
Статус: Отложено.
25. Улучшения модуля профиля пользователя на основе анализа (site)/profile:
Контекст: Модуль профиля является одним из наиболее современных и хорошо спроектированных в проекте. Он образцово реализует паттерн "Кухня-Зал", Server Actions и полный цикл шифрования PII. Однако, в нем присутствует архитектурная неконсистентность и большое количество "заглушек".
Задачи:
[Refactoring/Architecture] Унифицировать все мутации данных на Server Actions:
План: Провести рефакторинг функции handleSendVerificationEmail в ProfileClient.tsx. Заменить текущий fetch к API-маршруту /api/auth/send-verification-code на вызов соответствующего Server Action.
Цель: Достичь архитектурной консистентности, чтобы все операции по изменению данных в этом модуле работали через Server Actions.
[Feature] Реализовать функционал "заглушек":
План: Спланировать и последовательно реализовать функционал, который на данный момент представлен alert()'ами:
Привязка Telegram-аккаунта.
Управление активными сессиями (просмотр и отзыв).
Редактирование адреса доставки (ведет на отдельную страницу или в модальное окно).
Безопасное удаление аккаунта (с подтверждением через пароль или email).
Цель: Превратить страницу профиля в полнофункциональный центр управления аккаунтом.
[Code Quality] Улучшить обработку ошибок и состояний:
План: Внедрить более надежную систему управления состояниями (loading, error, success), возможно, через кастомный хук или react-hot-toast вместо отображения текстовых блоков. Стандартизировать формат ответов от Server Actions для единообразной обработки.
Цель: Повысить предсказуемость и надежность UX при взаимодействии с формой.
Статус: Отложено.
26. Улучшения страницы товара на основе product/[id]/page.tsx:
Контекст: Страница товара корректно реализует получение и подготовку данных на сервере, но использует неоптимальную для production-среды стратегию рендеринга и содержит захардкоженные бизнес-правила.
Задачи:
[Performance/High Priority] Заменить 'force-dynamic' на стратегию инкрементальной статической регенерации (ISR) с on-demand revalidation:
План:
Удалить export const dynamic = 'force-dynamic'.
Настроить ISR с адекватным временем жизни кэша (например, export const revalidate = 600; // 10 минут).
Реализовать on-demand revalidation. Создать API-маршрут или Server Action, который будет вызываться из админ-панели (при изменении товара) или вебхуком (при изменении остатков в "МойСклад") и принудительно обновлять кэш для конкретной страницы товара, используя revalidatePath().
Цель: Достичь идеального баланса между производительностью (отдавать кэш) и актуальностью данных (мгновенно обновлять кэш при изменениях).
[Refactoring] Централизовать логику сортировки размеров:
План: Вынести захардкоженный массив SIZE_ORDER в отдельный файл-конфигурацию (например, /src/config/sizes.ts) или, что еще лучше, создать в schema.prisma модель Size с полем order: Int и сортировать размеры на уровне запроса к базе данных (orderBy: { size: { order: 'asc' } }).
Цель: Сделать логику сортировки централизованной, управляемой и устранить "магические" константы из кода страниц.
Статус: Отложено.
27. Улучшения страницы каталога на основе (site)/catalog/page.tsx:
Контекст: Страница каталога корректно получает и отображает список товаров, но содержит три серьезных архитектурных проблемы: неоптимальную стратегию рендеринга, жестко захардкоженную бизнес-логику ("code smell") и нарушение принципа управления контейнером верстки.
Задачи:
[Performance/High Priority] Заменить 'force-dynamic' на стратегию инкрементальной статической регенерации (ISR):
План: Как и на других страницах, удалить 'force-dynamic' и настроить ISR с адекватным временем жизни кэша (например, revalidate = 300). Реализовать on-demand revalidation при изменении любого товара в админ-панели.
Цель: Снизить нагрузку на БД и значительно ускорить загрузку основной страницы каталога для большинства пользователей.
[Architecture/High Priority] Устранить захардкоженную логику для "Комплекта двойка":
План: Перенести эту логику из кода в данные. Например, добавить в модель ProductVariant в schema.prisma опциональное поле galleryImageUrls: String[]. Логика на странице должна просто проверять наличие этого поля и добавлять URL'ы из него, а не проверять название товара.
Цель: Устранить "магическую строку" и сделать логику отображения данных управляемой через админ-панель, а не через изменение кода.
[Refactoring/Layout] Удалить дублирующий контейнер верстки:
План: Удалить из этого файла <div class="container mx-auto ...">.
Цель: Привести компонент в соответствие с архитектурным принципом "Layout — Хозяин Контейнера", чтобы избежать проблем с версткой и обеспечить консистентность.
•		•	Статус: Отложено.
28. Устранение дублирования в модуле верификации email:
Контекст: Анализ выявил критическую архитектурную проблему: в проекте существуют две параллельные и конкурирующие системы для верификации email (.../(site)/verify-email и .../(site)/auth/verify-email), каждая со своим API-маршрутом и UI. Это является серьезным источником технического долга, усложняет поддержку и может привести к ошибкам в критически важном флоу.
Задачи:
[Architecture/High Priority] Унифицировать флоу верификации email:
План:
Провести аудит: Определить, какая из двух систем (/api/auth/verify-token или /api/auth/verify-email) генерируется и отправляется пользователю при регистрации или запросе повторной верификации.
Выбрать каноничную реализацию: Утвердить более современную и качественную реализацию (.../(site)/verify-email/page.tsx с его state-машиной) как единственный верный флоу.
Полностью удалить устаревший код: Удалить устаревший компонент (.../(site)/auth/verify-email/page.tsx) и связанный с ним API-маршрут (/api/auth/verify-email).
Проверить консистентность: Убедиться, что вся система теперь ссылается только на единый, каноничный маршрут верификации.
Цель: Создать единый, надежный и поддерживаемый процесс верификации email, устранив путаницу и избыточный код.
Статус: Отложено.
29. Улучшения Layout'а для страниц аутентификации на основе (auth)/layout.tsx:
Контекст: Данный layout является образцовым примером использования Route Group для UI-изоляции. Он корректно переопределяет родительский макет, создавая "чистый холст" для страниц логина и регистрации, что является лучшей практикой для UX в процессах аутентификации.
Задачи: На данный момент улучшений не требуется. Конфигурация является идеальной для своей задачи.
Статус: Завершено / Не требуется.
30. Улучшения флоу сброса пароля на основе reset-password/page.tsx:
Контекст: Реализация страницы сброса пароля является образцовой с точки зрения безопасности, используя паттерн "Server-Side Validation First". Она не отображает форму, пока токен не будет проверен на сервере. Однако, есть возможности для улучшения с точки зрения архитектуры кода и полноты цикла безопасности.
Задачи:
[Security] Обеспечить одноразовое использование токенов:
План: В Server Action, который обрабатывает смену пароля (внутри <ResetPasswordForm>), после успешного обновления пароля пользователя необходимо немедленно удалять использованный PasswordResetToken из базы данных.
Цель: Это критически важно для предотвращения атак повторного использования. Если токен не удалить, злоумышленник, получивший доступ к старому письму, сможет повторно использовать ссылку.
[Refactoring] Централизовать логику валидации токена:
План: Вынести функцию validateToken из page.tsx в более централизованное место (например, в /lib/auth.ts или новый /lib/token-utils.ts). Эта же функция должна вызываться и внутри Server Action перед сменой пароля, чтобы гарантировать консистентность правил валидации.
Цель: Следовать принципу DRY (Don't Repeat Yourself) и иметь единый источник правды для логики валидации токенов.
Статус: Отложено.
31. Улучшения флоу регистрации на основе register/page.tsx:
Контекст: Страница регистрации представляет собой сложный многошаговый компонент. Текущая реализация выполняет свою задачу, но имеет несколько архитектурных недостатков: хрупкая клиентская оркестрация (регистрация + авто-логин), использование устаревшего паттерна fetch и несоответствие отправляемых данных (name) актуальной схеме БД (name_encrypted, surname_encrypted).
Задачи:
[Architecture/High Priority] Перенести всю логику в единый Server Action:
План: Создать один Server Action, который инкапсулирует весь процесс:
Принимает данные формы (firstName, lastName, email, password).
Валидирует их с помощью Zod.
Создает пользователя в БД, шифруя PII.
Немедленно выполняет signIn на сервере.
Возвращает единый результат (успех или ошибка) на клиент.
Цель: Сделать процесс регистрации транзакционным и атомарным. Это устранит хрупкость клиентской оркестрации и полностью соответствует современной архитектуре Next.js.
[Refactoring/Data Integrity] Привести форму в соответствие со схемой БД:
План: Изменить логику отправки данных. Вместо объединения firstName и lastName в одно поле name, передавать их в Server Action как отдельные поля, чтобы они могли быть корректно зашифрованы и сохранены в name_encrypted и surname_encrypted соответственно.
Цель: Обеспечить консистентность данных между фронтендом и базой данных.
[Code Quality/UX] Внедрить react-hook-form с Zod-резолвером:
План: Рефакторить компонент, заменив ручное управление состоянием (useState для каждого поля) на библиотеку react-hook-form с @hookform/resolvers/zod.
Цель: Значительно упростить код, централизовать валидацию и улучшить управление состоянием формы (ошибки, isSubmitting).
[Refactoring/Styling] Устранить <style jsx>:
План: Заменить локальные стили из блока <style jsx> на стандартные utility-классы Tailwind CSS. Повторяющиеся стили (как .input-style) можно вынести в кастомный компонент <Input /> или в @apply в globals.css.
Цель: Обеспечить единый и консистентный подход к стилизации во всем проекте.
Статус: Отложено.
32. Улучшения флоу входа в систему на основе login/page.tsx:
Контекст: Страница входа реализует кастомный двухшаговый флоу аутентификации (валидация, затем отправка кода). Текущая реализация использует хрупкую клиентскую оркестрацию, выполняя две последовательные fetch-операции. Это делает процесс уязвимым для ошибок сети между шагами и использует устаревший архитектурный паттерн.
Задачи:
[Architecture/High Priority] Сделать процесс входа атомарным с помощью Server Action:
План: Создать единый Server Action, который будет инкапсулировать всю логику:
Принимает email и password.
Проверяет учетные данные.
В случае успеха, инициирует отправку кода подтверждения.
Возвращает на клиент единый ответ ({ success: true } или { error: '...' }).
Цель: Превратить двухшаговый процесс в единую, атомарную транзакцию с точки зрения клиента. Это радикально повысит надежность и безопасность флоу.
[Code Quality] Рефакторинг формы с react-hook-form:
План: Аналогично странице регистрации, заменить ручное управление состоянием (useState) на react-hook-form с Zod-резолвером для более чистой и надежной валидации и управления состоянием.
Цель: Упростить код компонента, улучшить UX при валидации полей.
Статус: Отложено.
33. Унификация флоу аутентификации (на основе login/verify-request/page.tsx):
Контекст: Существование этой страницы является неопровержимым доказательством критического архитектурного конфликта. Она обслуживает флоу верификации на основе ссылок, в то время как основной флоу входа в систему (login/page.tsx) построен на основе кодов. Наличие двух параллельных и конкурирующих систем аутентификации является серьезным техническим долгом, который необходимо устранить.
Задачи:
[Architecture/High Priority] Выбрать и реализовать единый каноничный флоу:
План:
Принять архитектурное решение: Определить, какой из механизмов — ссылки с токенами или одноразовые коды — является основным и единственным для всех сценариев (регистрация, вход, сброс пароля).
Провести полный рефакторинг: После принятия решения, необходимо провести аудит всего auth-кода.
Удалить устаревший флоу: Полностью удалить все компоненты (включая этот, verify-request/page.tsx), API-маршруты и Server Actions, относящиеся к невыбранному, устаревшему механизму.
Цель: Создать единый, предсказуемый и поддерживаемый процесс аутентификации/верификации для всего приложения.
Статус: Отложено.
34. Улучшения флоу подтверждения кода входа на основе verify-code/page.tsx:
Контекст: Компонент реализует сложную клиентскую оркестрацию для завершения входа: сначала он проверяет код через один API-маршрут, а затем, в случае успеха, передает полученные данные в signIn для создания сессии. Этот паттерн хрупок и уязвим для ошибок сети между двумя независимыми запросами.
Задачи:
[Architecture/High Priority] Сделать процесс верификации и входа атомарным с помощью Server Action:
План: Создать единый Server Action, который будет инкапсулировать всю логику:
Принимает email и code.
Проверяет их валидность на сервере.
В случае успеха, немедленно вызывает signIn на сервере с уже верифицированными данными.
Возвращает на клиент единый, простой результат ({ success: true } или { error: '...' }).
Цель: Превратить двухшаговый процесс в единую, атомарную транзакцию с точки зрения клиента, что радикально повысит надежность и безопасность флоу.
[Code Quality] Улучшить семантику состояний:
План: Рефакторить компонент, чтобы он использовал отдельное состояние для информационных сообщений (например, infoMessage), а состояние error — исключительно для ошибок.
Цель: Сделать код более читаемым, предсказуемым и легким для поддержки.
Статус: Отложено.
35. Улучшения страницы запроса на сброс пароля на основе forgot-password/page.tsx:
Контекст: Данный файл является образцовым примером использования React Server Components в качестве "контейнера". Он корректно рендерит статическую часть UI на сервере и делегирует всю интерактивную логику (саму форму) дочернему клиентскому компоненту (<ForgotPasswordForm />). Эта архитектура является чистой, производительной и соответствует лучшим практикам Next.js.
Задачи: На данный момент улучшений для этого файла не требуется. Его архитектура является эталонной. Все потенциальные улучшения будут относиться к дочернему компоненту <ForgotPasswordForm />, который будет проанализирован отдельно.
Статус: Завершено / Не требуется.
36. Улучшения формы запроса на сброс пароля:
Контекст: Форма является качественным и продуманным с точки зрения UX клиентским компонентом. Однако, она использует устаревший архитектурный паттерн (fetch к API Route) и может быть улучшена с точки зрения управления состоянием и безопасности.
Задачи:
[Architecture/High Priority] Мигрировать с API Route на Server Action:
План: Заменить текущий fetch-запрос на вызов Server Action. Это позволит удалить соответствующий API-маршрут, упростить код, улучшить типобезопасность и привести компонент в соответствие с современной архитектурой проекта (как в модуле профиля). Для отслеживания состояния загрузки использовать хук useTransition.
Цель: Унификация архитектуры, повышение надежности и поддерживаемости.
[Code Quality] Внедрить react-hook-form с Zod-резолвером:
План: Рефакторить компонент, заменив ручное управление состоянием (useState) на библиотеку react-hook-form с @hookform/resolvers/zod.
Цель: Упростить код управления формой, централизовать правила валидации (использовать единую Zod-схему на клиенте и в Server Action) и улучшить UX при обработке ошибок валидации.
[Security] Реализовать Rate Limiting (ограничение частоты запросов):
План: На стороне бэкенда (в Server Action) внедрить механизм rate-limiting'а, который не позволит одному пользователю/IP-адресу запрашивать сброс пароля слишком часто (например, не чаще одного раза в 60 секунд). На клиенте, после успешной отправки, можно добавить таймер обратного отсчета на кнопку для улучшения UX.
Цель: Предотвратить злоупотребление функцией и спам почтовыми сообщениями.
37. Улучшения формы сброса пароля на основе ResetPasswordForm.tsx:
Контекст: Компонент является частью образцового и безопасного флоу "Server-Side Validation First". Он хорошо спроектирован с точки зрения UX. Однако, как и другие формы в auth-модуле, он использует устаревший архитектурный паттерн (fetch к API Route) и может быть улучшен.
Задачи:
[Architecture/High Priority] Мигрировать с API Route на Server Action:
План: Заменить текущий fetch-запрос на вызов Server Action. Внутри этого Server Action необходимо инкапсулировать всю логику: повторную проверку токена, обновление пароля пользователя и, что критически важно, удаление использованного токена из базы данных для предотвращения атак повторного использования.
Цель: Сделать процесс смены пароля единой, атомарной транзакцией. Это повысит безопасность, упростит код (удаление API-маршрута) и приведет компонент в соответствие с современной архитектурой проекта.
[Code Quality] Внедрить react-hook-form с Zod-резолвером:
План: Рефакторить компонент, заменив ручное управление состоянием (useState) на react-hook-form. Создать Zod-схему для валидации полей (минимальная длина, совпадение паролей).
Цель: Упростить и сделать более надежным код управления формой и валидации.
[UX] Улучшить отображение требований к паролю:
План: Добавить под полем ввода пароля динамическую подсказку, которая будет в реальном времени показывать, какие требования к паролю уже выполнены (например, "✓ 8 символов", "✓ Совпадает с подтверждением").
Цель: Улучшить пользовательский опыт, помогая пользователю создать корректный пароль с первого раза.
38. Улучшения компонента CodeInput.tsx:
Контекст: Компонент является высококачественным, переиспользуемым UI-примитивом с образцовой реализацией сложного UX (авто-фокус, вставка из буфера). Его архитектура (управляемый компонент) является корректной. Однако, его можно сделать еще более надежным и доступным для всех пользователей.
Задачи:
[Accessibility] Улучшить доступность (a11y):
План: Добавить к каждому элементу <input> атрибут aria-label для предоставления контекста пользователям, использующим скринридеры. Например, aria-label={Цифра ${index + 1} из ${length}}. Это позволит озвучивать назначение каждого поля, а не просто "поле ввода".
Цель: Обеспечить соответствие стандартам доступности и улучшить опыт для пользователей со вспомогательными технологиями.
[Refactoring/UX] Внедрить визуальное состояние ошибки:
План: Добавить в компонент новый пропс hasError: boolean. Если hasError равно true, к инпутам должны применяться стили, указывающие на ошибку (например, красная рамка).
Цель: Повысить переиспользуемость компонента и улучшить обратную связь для пользователя, явно показывая, когда введенный код неверен.
[Future] Рассмотреть поддержку разных типов ввода:
План: В будущем, если потребуется, можно добавить пропс inputType: 'numeric' | 'alphanumeric', который будет управлять регулярным выражением для валидации ввода.
Цель: Сделать компонент еще более гибким для использования в других сценариях (например, для ввода промокодов).
39. Улучшения модального окна верификации (VerificationModal.tsx):
Контекст: Компонент является сложным и хорошо спроектированным "мини-приложением". Его ключевое преимущество — правильное использование router.refresh() для обновления серверных данных без перезагрузки страницы. Однако, он все еще построен на устаревшем архитектурном паттерне (fetch к API Routes), что создает неконсистентность с более современными частями проекта.
Задачи:
[Architecture/High Priority] Мигрировать всю логику на Server Actions:
План: Полностью рефакторить компонент, заменив оба fetch-запроса (/api/auth/send-verification-code и /api/auth/verify-code) на вызовы соответствующих Server Actions. Состояние загрузки должно управляться через хук useTransition.
Цель: Достичь полной архитектурной унификации с другими современными компонентами (как в модуле профиля). Это позволит удалить два API-маршрута, упростить код, повысить типобезопасность и централизовать бизнес-логику на сервере.
[Code Quality] Устранить "магические строки":
План: В качестве промежуточного шага (или если миграция на Server Actions будет отложена), вынести жестко закодированные URL-адреса API-маршрутов в централизованный файл с константами (например, /src/config/api.ts).
Цель: Повысить поддерживаемость кода и избежать ошибок, связанных с рассинхронизацией путей.
[Refactoring] Улучшить управление состоянием UI:
План: Рефакторить управление состоянием, объединив error и success в единый объект состояния, например: const [status, setStatus] = useState({ type: 'idle' | 'error' | 'success', message: '' }).
Цель: Сделать код компонента более предсказуемым и надежным, исключив возможность возникновения некорректных состояний (например, одновременного отображения ошибки и сообщения об успехе).
40. Улучшения AppCore.tsx (Главный Оркестратор):
Контекст: Компонент является архитектурным ядром клиентской части, грамотно управляя глобальными элементами и побочными эффектами. Однако, он содержит несколько "code smells", которые создают неявные зависимости и снижают поддерживаемость.
Задачи:
[Architecture/Refactoring] Устранить хрупкую связь между Layout и Header:
План: Рефакторить CSS-архитектуру, чтобы избавить AppCore.tsx от необходимости вручную добавлять paddingTop к основному контенту. Это можно достичь, сделав ConditionalHeader всегда sticky и управляя его высотой через CSS, или перестроив разметку на CSS Grid.
Цель: Создать более надежную и самодостаточную систему верстки, где компоненты не зависят от внутренних деталей реализации друг друга.
[Refactoring] Централизовать логику определения маршрутов:
План: Вынести логику определения типа страницы (isAuthPage, isProfilePage и т.д.) из компонента в отдельный файл-хелпер (например, /src/lib/paths.ts). Компонент должен будет вызывать функции из этого хелпера (например, isAuthPath(pathname)), а не использовать pathname.startsWith().
Цель: Устранить "магические строки", повысить читаемость и упростить поддержку маршрутов при их изменении.
[Code Quality] Инкапсулировать побочные эффекты в кастомные хуки:
План: Вынести сложную логику из useEffect (например, блокировку скролла или управление жестами) в переиспользуемые кастомные хуки, такие как useScrollLock(isLocked) или useGesturePrevention().
Цель: Сделать компонент AppCore чище, а сложную логику — переиспользуемой и легко тестируемой.
41. Улучшения "Диспетчера Хедеров" (ConditionalHeader.tsx):
Контекст: Компонент является отличным примером паттерна "Компонент-маршрутизатор", который централизует логику выбора UI. Однако, он дублирует логику определения маршрутов из AppCore.tsx, используя "магические строки", что делает систему хрупкой.
Задачи:
[Architecture/High Priority] Устранить дублирование логики маршрутизации:
План: Провести рефакторинг, используя тот же централизованный хелпер (/src/lib/paths.ts), который был предложен для AppCore.tsx. Вместо pathname.startsWith(...) компонент должен вызывать функции, такие как isProductPath(pathname) и isHybridHeaderPath(pathname).
Цель: Создать единый источник правды для логики, связанной с URL-адресами, и полностью следовать принципу DRY (Don't Repeat Yourself).
[Refactoring] Унифицировать стилизацию оберток:
План: Принять архитектурное решение: либо ConditionalHeader предоставляет консистентную обертку (например, <div className="w-full bg-white">) для всех хедеров, либо он не предоставляет ее вовсе, и каждый дочерний хедер (Header, HybridHeader и т.д.) становится полностью ответственным за свой собственный фон и позиционирование.
Цель: Повысить предсказуемость и консистентность визуального отображения шапки на разных страницах.
[Future/Architecture] Рефакторинг в декларативную конфигурацию:
План: Когда количество типов хедеров увеличится, рассмотреть возможность рефакторинга текущей цепочки if/else if/else в более декларативную структуру, например, в массив конфигураций [{ pathMatcher: (path) => boolean, component: React.Component }], по которому можно будет итерироваться.
Цель: Повысить масштабируемость и читаемость компонента в долгосрочной перспективе.
42. Улучшения стандартного хедера (Header.tsx):
Контекст: Компонент является хорошим примером презентационного ("глупого") компонента, но содержит архитектурную неконсистентность в управлении состоянием и незавершенный функционал поиска.
Задачи:
[Architecture/High Priority] Унифицировать управление состоянием меню:
План: Устранить смешанный подход к управлению состоянием. Необходимо удалить прямое использование useAppStore из этого компонента. Вместо этого, родительский компонент (ConditionalHeader) должен передавать функцию setFloatingMenuOpen в пропс onMenuToggle.
Цель: Сделать компонент полностью презентационным, предсказуемым и соответствующим чистому архитектурному паттерну.
[Feature] Реализовать логику поиска:
План: "Поднять" состояние searchQuery из локального (useState) в глобальное хранилище Zustand. При изменении этого состояния должен активироваться компонент SearchOverlay, который будет использовать searchQuery для фильтрации продуктов и отображения результатов.
Цель: Превратить UI поиска в полнофункциональный инструмент.
[Refactoring] Устранить проп contentOpacity для улучшения инкапсуляции:
План: Проанализировать использование пропа contentOpacity, который, вероятно, используется для анимации прокрутки в HybridHeader. Рефакторить эту логику так, чтобы она не "протекала" в дочерний компонент. Анимация прозрачности должна быть ответственностью родительского компонента, который может оборачивать Header в анимированный div.
Цель: Уменьшить связанность (coupling) компонентов и сделать Header более независимым и переиспользуемым.
43. Улучшения "Гибридного Хедера" (HybridHeader.tsx):
Контекст: Компонент является образцовым примером "умной" обертки, которая выносит всю сложную логику в кастомный хук. Его метод коммуникации с AppCore через CSS-переменную является элегантным решением. Однако, он создает "протекающую абстракцию", передавая детали своей внутренней анимации дочернему компоненту.
Задачи:
[Architecture/High Priority] Устранить "протекающую абстракцию" с contentOpacity:
План: Рефакторить компонент так, чтобы он сам управлял прозрачностью, а не делегировал это дочернему Header. Вместо передачи пропа contentOpacity, HybridHeader должен оборачивать <Header> в дополнительный <div> и применять стиль opacity непосредственно к этой обертке.
Цель: Достичь полной инкапсуляции. Это сделает дочерний Header более простым и по-настояшему "глупым" компонентом, не зависящим от анимационной логики своего родителя.
[Performance/Refactoring] Оптимизировать обновление CSS-переменной:
План: Заменить useEffect на useLayoutEffect для установки переменной --header-height. Это гарантирует, что CSS-переменная будет обновлена после того, как React рассчитает DOM, но до того, как браузер отрисует кадр.
Цель: Устранить теоретическую возможность визуального "прыжка" (flicker) на один кадр и сделать обновление высоты более надежным.
[Code Quality] Упростить передачу пропсов:
План: Вместо того, чтобы извлекать каждое состояние из Zustand и передавать его по отдельности, можно передать объект headerProps или использовать spread-оператор, если дочерний Header будет рефакторен для принятия такого объекта.
Цель: Сделать код компонента более компактным и читаемым.
44. Улучшения хука useHybridHeader.ts:
Контекст: Данный хук является технически сложным и образцово реализованным произведением. Он использует лучшие практики для производительности (requestAnimationFrame, пассивные слушатели) и UX (snapToEdge). Его архитектура и реализация на текущий момент являются эталонными.
Задачи:
[Documentation] Добавить JSDoc комментарии:
План: Так как хук содержит сложную, нетривиальную логику, необходимо добавить подробные JSDoc комментарии, объясняющие:
Назначение хука.
Роль каждого useRef состояния (ticking, lastScrollY и т.д.).
Принцип работы паттерна requestAnimationFrame.
Логику "прилипания к краям".
Цель: Повысить поддерживаемость кода в долгосрочной перспективе. Это позволит любому разработчику в будущем быстро понять, как работает этот сложный механизм, без необходимости многочасового анализа.
[Refactoring] Устранить "магические числа":
План: Вынести числовые константы, определяющие поведение анимации (например, smallDelta = 8, snapThreshold = 0.53, timeout = 150), в именованные константы в начале файла.
Цель: Улучшить читаемость и упростить настройку "физики" поведения хедера в будущем.
Статус: На данный момент серьезного архитектурного рефакторинга не требуется. Задачи носят характер улучшения качества и поддерживаемости кода.
45. Улучшения "Плавающего Меню" (FloatingMenuOverlay/index.tsx):
Контекст: Компонент является хорошо структурированным "оркестратором", который грамотно компонует UI из дочерних элементов. Однако, он содержит критическую неконсистентность, связанную с незавершенным рефакторингом, и продолжает использовать "магические числа" для z-index.
Задачи:
[Bug/High Priority] Устранить неконсистентность при вызове VerificationModal:
План: Провести аудит и принять окончательное решение. Либо VerificationModal действительно больше не требует email как пропс (и тогда нужно удалить передачу email={user?.email}), либо он все еще нужен (и тогда нужно удалить вводящий в заблуждение комментарий).
Цель: Привести код в соответствие с его реальной логикой, устранив потенциальный баг и технический долг.
[Architecture] Применить централизованную систему z-index:
План: Заменить жестко закодированный класс z-[100] на семантический класс, который будет определен в tailwind.config.ts (например, z-overlayMenu), как это было предложено в задаче №22.
Цель: Продолжить унификацию управления z-index и сделать UI более надежным.
[Refactoring] Устранить "prop drilling" с помощью React Context:
План: Создать небольшой, локальный для этого модуля MenuContext, который будет предоставлять функцию onClose. FloatingMenuOverlay будет провайдером этого контекста, а любой вложенный компонент, которому нужна эта функция, сможет получить ее напрямую через useContext, избавляя промежуточные компоненты от необходимости "пробрасывать" пропсы.
Цель: Упростить передачу данных, уменьшить связанность компонентов и сделать архитектуру модуля более чистой и масштабируемой.
46. Улучшения "Шапки Меню" (MenuHeader.tsx):
Контекст: Компонент реализует продуманный UX-переход к глобальному поиску, но содержит критическую архитектурную проблему — целый блок UI для внутреннего поиска является "мертвым кодом" ("зомби-фича"). Также присутствуют "code smells" в виде жестко закодированных значений.
Задачи:
[Architecture/High Priority] Устранить недостижимый код ("Зомби-фича"):
План: Полностью удалить локальное состояние isSearchModeActive и всю условную логику рендеринга, связанную с ним. Оставить только тот JSX, который отображается в ветке !isSearchModeActive, так как другая ветка никогда не может быть достигнута.
Цель: Радикально упростить компонент, повысить его читаемость и удалить нефункциональный, вводящий в заблуждение код.
[Refactoring] Устранить жестко закодированный URL:
План: Заменить абсолютную ссылку href="https://kyanchir.ru" на относительную href="/".
Цель: Обеспечить корректную работу и переносимость компонента между различными окружениями (development, staging, production).
[Refactoring] Централизовать управление отступами:
План: Вместо ручного подбора "магических чисел" для padding, создать в tailwind.config.ts или в globals.css общие CSS-переменные для вертикальных и горизонтальных отступов хедера (например, --header-py и --header-px), которые будут использоваться и в Header.tsx, и в MenuHeader.tsx.
Цель: Создать единый источник правды для ключевых метрик layout'а и устранить хрупкие неявные зависимости.
[Architecture] Привести компонент к чистому "Dumb Component" паттерну:
План: Удалить прямое использование useAppStore из компонента. Функция setSearchActive должна передаваться как пропс от родительского FloatingMenuOverlay, который и будет отвечать за связь с глобальным хранилищем.
Цель: Усилить инкапсуляцию, повысить переиспользуемость и тестируемость компонента, следуя единому архитектурному паттерну.
47. Улучшения блока аутентифицированного пользователя (AuthenticatedView.tsx):
Контекст: Компонент эффективно отображает персонализированные данные, но нарушает чистоту паттерна "Dumb Component", инкапсулируя собственную fetch-логику. Эта логика дублируется в других частях приложения, а также содержит жестко закодированные URL.
Задачи:
[Architecture/High Priority] Централизовать логику отправки кода верификации через Server Action:
План: Создать единый, переиспользуемый Server Action для отправки кода верификации. Удалить из AuthenticatedView.tsx локальное состояние (isLoading, error) и fetch-запрос. Компонент должен просто вызывать этот Server Action.
Цель: Устранить дублирование кода (DRY), привести компонент к чистому "Dumb" паттерну и унифицировать архитектуру обработки форм и запросов во всем приложении.
[Refactoring] Устранить жестко закодированный URL админ-панели:
План: Заменить захардкоженную ссылку https://admin.kyanchir.ru/dashboard на значение из переменной окружения (например, process.env.NEXT_PUBLIC_ADMIN_URL), как это было предложено для middleware.ts.
Цель: Сделать компонент переносимым между окружениями и централизовать управление системными URL.
[Code Quality/Refactoring] Вынести и унифицировать тип UserSession:
План: Локальный интерфейс UserSession должен быть удален. Вместо него компонент должен импортировать и использовать глобальный тип User из next-auth или кастомный тип сессии, определенный в src/types/next-auth.d.ts.
Цель: Создать единый источник правды для структуры данных пользователя и обеспечить типобезопасность во всем приложении.
48. Анализ GuestView.tsx:
Контекст: Компонент является образцовым примером чистого, минималистичного и сфокусированного "Dumb Component". Он идеально выполняет свою единственную задачу — предоставить гостю ссылку для входа, — и делает это без каких-либо архитектурных недостатков или "code smells".
Задачи: На данный момент улучшений не требуется. Компонент является эталонной реализацией для своей роли.
Статус: Завершено / Не требуется.
49. Улучшения виджета статуса доставки (DeliveryStatus.tsx):
Контекст: Компонент является хорошо спроектированным UI-макетом ("mockup"), который наглядно демонстрирует будущий функционал. Его главная проблема в том, что он полностью статичен и использует жестко закодированные данные, не являясь на данный момент функциональным элементом.
Задачи:
[Feature/High Priority] Превратить макет в функциональный компонент:
План:
Реализовать логику получения последнего активного заказа пользователя. Эти данные должны передаваться в компонент через пропсы.
Заменить все захардкоженные значения ("Заказ #337", "Розовая пижама") на реальные данные из полученного объекта заказа.
Реализовать логику, при которой компонент не рендерится вовсе, если у пользователя нет активных заказов.
Цель: Трансформировать компонент из визуальной заглушки в полезный, data-driven виджет.
[Refactoring] Сделать прогресс-бар динамическим:
План: Создать функцию-хелпер или маппинг, который будет преобразовывать статус заказа (например, 'PROCESSING', 'SHIPPED') в процентное значение для width прогресс-бара. Удалить "магическое число" 33.33%.
Цель: Обеспечить точное визуальное соответствие UI реальному статусу заказа.
[UX] Рассмотреть сохранение состояния "аккордеона":
План: Оценить, должно ли состояние isDeliveryOpen сохраняться между сессиями. Если да, перенести его из локального useState в localStorage или в глобальное хранилище Zustand.
Цель: Улучшить UX, запоминая предпочтения пользователя по отображению этого блока.
50. Улучшения сводки по корзине (CartSummary.tsx):
Контекст: Компонент является не просто макетом, а макетом со сломанным UX. Он использует статичные данные и имитирует интерактивность (кнопка-аккордеон), которая не приводит ни к какому полезному действию, создавая ложные ожидания у пользователя.
Задачи:
[Feature/High Priority] Превратить макет в функциональный компонент:
План: Подключить компонент к глобальному хранилищу Zustand, чтобы получать реальные данные о товарах в корзине. Динамически вычислять itemCount и totalPrice на основе этих данных. Если корзина пуста, отображать "0" и "0 RUB".
Цель: Трансформировать компонент из статичной заглушки в живой, data-driven виджет.
[UX/High Priority] Реализовать навигацию в корзину:
План: Полностью изменить логику. Весь компонент должен стать единой ссылкой (<Link href="/cart">). По клику должно происходить закрытие меню (onClose) и переход на страницу корзины.
Цель: Исправить сломанный UX и заставить компонент выполнять действие, которое от него ожидает пользователь.
[Refactoring] Удалить неиспользуемую логику "аккордеона":
План: Полностью удалить локальное состояние isCartOpen и onClick обработчик, так как они станут не нужны после превращения компонента в ссылку. Иконку-шеврон следует оставить как визуальный индикатор навигации.
Цель: Упростить код, удалив "мертвую" логику.
51. Улучшения навигации по магазину (ShopNavigation.tsx):
Контекст: Компонент является статичным макетом с полностью нефункциональной навигацией. Он использует жестко закодированные данные и создает негативный UX, предоставляя "мертвые" ссылки.
Задачи:
[Feature/High Priority] Превратить макет в динамический навигационный компонент:
План:
Модифицировать компонент так, чтобы он принимал через пропсы массив объектов категорий (полученных из БД на более высоком уровне).
Заменить жестко закодированные <div> на итерацию (.map()) по массиву категорий.
Каждый элемент в итерации должен рендерить компонент Next.js <Link>, ведущий на соответствующую страницу каталога (например, href="/catalog?category=${category.slug}").
Цель: Трансформировать компонент из нерабочей заглушки в основной инструмент навигации по каталогу.
[UX] Обеспечить обратную связь для активной категории:
План: Модифицировать компонент так, чтобы он мог определять текущую активную категорию (например, считывая searchParams из URL). Активной ссылке-категории должен применяться особый стиль (например, другой цвет или жирное начертание), чтобы пользователь понимал, в каком разделе он находится.
Цель: Улучшить навигацию и ориентацию пользователя в каталоге.
52. Улучшения блока информационных ссылок (InfoLinks.tsx):
Контекст: Компонент является статичным макетом с полностью нефункциональными "ссылками", что создает негативный UX. Управление ссылками требует изменения кода.
Задачи:
[Feature/High Priority] Превратить макет в функциональный компонент:
План: Заменить неинтерактивные <div> на компоненты Next.js <Link>, ведущие на соответствующие страницы (/faq/k-coins, /support/size-guide, /support).
Цель: Исправить сломанный UX, сделав ссылки кликабельными и функциональными.
[Refactoring/Architecture] Централизовать управление навигацией:
План: Удалить жестко закодированные строки из JSX. Создать в директории /src/config файл navigation.ts, в котором будет храниться массив объектов, описывающих все навигационные ссылки (например, const infoLinks = [{ title: 'Что такое К-койны?', href: '...' }]). Компонент InfoLinks должен импортировать этот массив и рендерить его с помощью .map().
Цель: Создать единый источник правды для всех навигационных ссылок в приложении, упростить их добавление/удаление и следовать принципу DRY.
53. Улучшения "Подвала Меню" (MenuFooter.tsx):
Контекст: Компонент является третьим подряд статичным макетом в модуле меню с нефункциональными ссылками. Он страдает от тех же проблем, что и InfoLinks.tsx.
Задачи:
[Feature/High Priority] Превратить макет в функциональный компонент:
План: Заменить неинтерактивные <div> на компоненты Next.js <Link>, ведущие на соответствующие страницы (например, /policy, /privacy).
Цель: Исправить сломанный UX, сделав ссылки кликабельными.
[Architecture] Централизовать управление навигацией:
План: Перенести данные для этих ссылок (заголовок и href) в тот же централизованный файл /src/config/navigation.ts, который был предложен в задаче №52. Компонент должен импортировать этот массив и рендерить его с помощью .map().
Цель: Создать единый источник правды для всех навигационных ссылок, следуя принципу DRY.
54. Анализ MenuButton.tsx:
Контекст: Компонент является эталонной реализацией переиспользуемого, чистого и гибкого UI-примитива ("Dumb Component"). Он полностью следует принципу единственной ответственности и не имеет архитектурных недостатков.
Задачи: На данный момент улучшений не требуется. Компонент является образцовой реализацией для своей роли.
Статус: Завершено / Не требуется.
55. Улучшения "Шага Статуса" (StatusStep.tsx):
Контекст: Компонент является хорошим примером UI-примитива, но содержит критический "code smell" в виде хрупкой и нечитаемой логики CSS-классов, основанной на замене строк.
Задачи:
[Architecture/High Priority] Рефакторинг хрупкой CSS-логики:
План: Полностью удалить цепочку вызовов .replace(). Вместо этого создать отдельный, явный object-lookup для определения класса Flexbox-выравнивания.
Пример: const flexAlignClass = { left: 'items-start', center: 'items-center', right: 'items-end' }[align];
Цель: Заменить "умную", но хрупкую и нечитаемую реализацию на простую, надежную и декларативную, что радикально повысит поддерживаемость компонента.
[Refactoring] Устранить "магические числа":
План: Провести аудит значений в классах трансформации (например, translate-x-[5px]). Если эти значения являются частью общей дизайн-системы, вынести их в tailwind.config.ts.
Цель: Обеспечить консистентность верстки и следовать принципу "единого источника правды" для дизайн-токенов.
56. Улучшения Footer.tsx:
Контекст: Компонент является образцовой реализацией React Server Component для статического UI, что обеспечивает максимальную производительность. Его единственный незначительный недостаток — наличие жестко закодированной строки.
Задачи:
[Refactoring] Централизовать метаданные сайта:
План: Создать централизованный файл конфигурации (например, /src/config/siteMetadata.ts). Вынести из футера строку 'Ghost-Engineer' в этот файл. Компонент Footer должен будет импортировать и использовать это значение.
Цель: Устранить "магические строки", централизовать управление метаданными сайта (название, владелец и т.д.) и повысить поддерживаемость.
57. Улучшения NetworkStatusManager.tsx:
Контекст: Компонент является образцовым примером "безголового" менеджера эффектов. Его логика чиста, надежна и отлично декомпозирована. Единственный незначительный недостаток — нарушение архитектурной конвенции проекта.
Задачи:
[Architecture/Refactoring] Централизовать компонент иконки:
План: Переместить локально определенный компонент WifiSlashIcon в общую директорию /src/components/icons/WifiSlashIcon.tsx. NetworkStatusManager должен будет импортировать его оттуда.
Цель: Обеспечить строгую архитектурную консистентность, поддерживая принцип "единого источника правды" для всех UI-примитивов (иконок) в проекте.
58. Улучшения NotificationManager.tsx:
Контекст: Компонент является отличным примером пассивного "рендерера", управляемого глобальным состоянием. Однако, он имеет серьезные недостатки в области доступности (a11y) и использует немасштабируемую логику для стилизации.
Задачи:
[Accessibility/High Priority] Обеспечить доступность для скринридеров:
План: Добавить к корневому <div> компонента ARIA-атрибуты: role="alert" и aria-live="assertive".
Цель: Сделать уведомления доступными для пользователей со вспомогательными технологиями. Атрибуты заставят скринридеры автоматически озвучивать сообщение при его появлении.
[Refactoring] Сделать логику стилей масштабируемой:
План: Заменить текущий тернарный оператор для bgColor на более гибкий object-lookup (map). Пример: const bgMap = { success: 'bg-green-500', error: 'bg-red-500', warning: 'bg-yellow-500' };.
Цель: Упростить добавление новых типов уведомлений (warning, info) в будущем без необходимости переписывать логику.
[Architecture] Применить централизованную систему z-index:
План: Заменить жестко закодированный класс z-[100] на семантический класс из tailwind.config.ts (например, z-notification).
Цель: Устранить "магические числа" и обеспечить консистентность управления слоями UI.
59. Улучшения SearchOverlay.tsx:
Контекст: Компонент является "оболочкой" для будущего функционала поиска и реализует продвинутый паттерн для анимации монтирования/размонтирования. Однако он содержит критический архитектурный недостаток в виде жестко закодированной высоты хедера, что нарушает связь с динамическим HybridHeader.
Задачи:
[Architecture/High Priority] Устранить жестко закодированную высоту хедера:
План: Полностью удалить "магическое число" const headerHeight = 64;. Вместо этого, компонент должен считывать значение из CSS-переменной --header-height при помощи JavaScript (getComputedStyle(document.documentElement).getPropertyValue('--header-height')) и использовать его для вычисления top.
Цель: Восстановить архитектурную целостность и создать надежную связь с динамической высотой хедера, которую устанавливает HybridHeader.
[Feature] Реализовать функционал поиска:
План: Наполнить "оболочку" реальным содержанием: добавить поле для ввода (которое будет синхронизироваться с searchQuery из Zustand), реализовать логику фильтрации/запроса товаров и отобразить результаты поиска в виде списка ProductCard.
Цель: Превратить компонент-заглушку в полнофункциональный инструмент поиска.
[Refactoring] Синхронизировать длительность анимации:
План: Вынести значение 300 в именованную константу (например, const ANIMATION_DURATION = 300;). Использовать эту константу и в setTimeout, и для генерации Tailwind-класса (например, через className={... duration-[${ANIMATION_DURATION}ms]}).
Цель: Создать единый источник правды для параметров анимации, устранив риск рассинхронизации.
[Architecture] Применить централизованную систему z-index:
План: Заменить жестко закодированный класс z-30 на семантический класс из tailwind.config.ts (например, z-searchOverlay).
Цель: Продолжить унификацию управления слоями UI.
60. Анализ и улучшение DynamicHeroSection.tsx:
Контекст: Компонент является не UI-элементом, а стратегией оптимизации производительности, которая отключает SSR для "тяжелого" дочернего компонента. Эта стратегия является осознанным компромиссом.
Задачи:
[Architecture/Performance] Провести аудит необходимости ssr: false:
План: При обновлении ключевых зависимостей (например, анимационной библиотеки внутри HeroSection) необходимо регулярно проверять, не появилась ли возможность рендерить компонент на сервере.
Цель: Включить SSR для этого компонента, если это станет возможным, чтобы улучшить SEO и метрику LCP (Largest Contentful Paint).
[UX] Улучшить UI загрузчика (Placeholder):
План: Заменить текущую простую серую заглушку на более продвинутый "скелетный" загрузчик (Skeleton Loader), который имитирует структуру реального HeroSection. Можно добавить ему плавную пульсирующую анимацию.
Цель: Улучшить воспринимаемую производительность и сделать процесс загрузки более эстетичным для пользователя.
61. Улучшения HeroSection.tsx:
Контекст: Компонент является "умной" оберткой, использующей продвинутые техники для JS-адаптивности, но на данный момент является статичным макетом с жестко закодированными данными и флагами отладки.
Задачи:
[Feature/High Priority] Интегрировать с реальным источником данных:
План: Заменить статичный массив DUMMY_MAIN_BANNERS на логику получения данных. Так как компонент является клиентским, он должен будет использовать fetch (например, через SWR или react-query) для загрузки данных о баннерах из API-маршрута или напрямую из Headless CMS.
Цель: Превратить компонент из макета в динамический, управляемый контентом элемент.
[Refactoring] Устранить отладочный флаг:
План: Заменить жестко закодированный проп isDebugMode={true} на условный, зависящий от окружения: isDebugMode={process.env.NODE_ENV === 'development'}.
Цель: Предотвратить утечку отладочной информации и поведения в production-сборку.
[Performance] Оптимизировать обработчик resize:
План: "Обернуть" функцию handleResize в debounce. Это можно сделать с помощью небольшой утилиты или кастомного хука, чтобы функция setCurrentWidth вызывалась не постоянно во время изменения размера, а только один раз после того, как пользователь закончил изменять размер окна.
Цель: Снизить количество ненужных перерисовок компонента и повысить производительность на десктопных устройствах.
62. Улучшения MiniBannerSlider.tsx:
Контекст: Компонент является мощной и хорошо спроектированной абстракцией над библиотекой Swiper, но содержит критическую проблему с типизацией (useRef<any>) и другие, менее серьезные "code smells".
Задачи:
[Code Quality/High Priority] Устранить тип any для swiperRef:
План: Импортировать тип Swiper из библиотеки swiper/types и использовать его для типизации useRef: const swiperRef = useRef<Swiper | null>(null);.
Цель: Восстановить типобезопасность, улучшить автодополнение кода и предотвратить потенциальные ошибки времени выполнения.
[Performance] Оптимизировать обработчик resize:
План: "Обернуть" функцию handleResize в debounce, чтобы она срабатывала только после завершения изменения размера окна, а не постоянно в процессе.
Цель: Снизить количество ненужных вычислений и повысить производительность.
[Refactoring] Сделать логику getDebugSpecs более надежной:
План: Рефакторить компонент, чтобы он принимал проп с явным соотношением сторон (например, aspectRatio="16/9"), а не CSS-класс. Компонент должен сам формировать и CSS-класс, и использовать этот проп для надежной логики в switch.
Цель: Устранить хрупкую зависимость от строкового значения CSS-класса и сделать компонент более надежным.
[Feature] Подключить к реальному источнику данных:
План: Эта задача аналогична задаче №61, но на более низком уровне. После того как родительский компонент научится получать данные, MiniBannerSlider должен быть готов принять и корректно отобразить их.
Цель: Завершить трансформацию компонента из макета в полнофункциональный элемент.
63. Улучшения "Контроллера Интерактива" (ClientInteractivity.tsx):
Контекст: Компонент является центральным "контроллером", который реализует продвинутые UX-паттерны (динамическое позиционирование, надежная блокировка скролла). Однако он дублирует логику блокировки скролла, содержит "магические числа" и нарушает конвенцию по использованию иконок.
Задачи:
[Architecture/High Priority] Унифицировать логику блокировки скролла:
План: Провести рефакторинг. Удалить более простую логику блокировки скролла из AppCore.tsx. Продвинутую реализацию из ClientInteractivity.tsx вынести в переиспользуемый кастомный хук (useBodyScrollLock(isLocked)). И AppCore (для оверлея поиска), и ClientInteractivity (для меню) должны будут использовать этот единый хук.
Цель: Создать единый, надежный и DRY-совместимый механизм для управления блокировкой скролла во всем приложении.
[Refactoring] Устранить "магические числа" и встроенный SVG:
План:
Вынести числовые значения для позиционирования (96, 7rem) в tailwind.config.ts.
Вынести встроенный SVG-код иконки "крестик" в отдельный компонент в директорию /src/components/icons, как это сделано для всех остальных иконок.
Цель: Обеспечить консистентность кода, следовать архитектурным конвенциям проекта и повысить поддерживаемость.
[UX/Refactoring] Пересмотреть необходимость третьей кнопки закрытия:
План: Провести UX-аудит. Так как FloatingMenuOverlay уже имеет собственную кнопку закрытия (MenuHeader), а также может закрываться по свайпу или нажатию на escape, наличие третьей, внешней кнопки может быть избыточным и загромождать UI. Рассмотреть возможность ее удаления.
Цель: Упростить UI и сделать взаимодействие более предсказуемым.
64. Улучшения FloatingLogoButton.tsx:
Контекст: Компонент реализует сложную и продуманную UX-логику для анимации и позиционирования. Однако его реализация страдает от неоптимального обработчика скролла и большого количества "магических чисел", что снижает производительность и поддерживаемость.
Задачи:
[Performance] Оптимизировать обработчик скролла:
План: Рефакторить useEffect, обернув логику handleScroll в requestAnimationFrame. Это гарантирует, что setOpacity будет вызываться не чаще, чем браузер может отрисовать, что является золотым стандартом для производительных анимаций на основе скролла.
Цель: Снизить нагрузку на CPU во время прокрутки и сделать анимацию более плавной.
[Refactoring] Централизовать "магические числа":
План: Вынести все числовые константы, управляющие анимацией (GHOST_OPACITY, ACTIVATION_THRESHOLD, BASE_BOTTOM_OFFSET и т.д.), в именованные константы в начале файла.
Цель: Улучшить читаемость кода, сделать его самодокументируемым и упростить настройку "физики" поведения кнопки в будущем.
[Code Quality/DRY] Упростить условный рендеринг иконок:
План: Вместо двух почти идентичных JSX-блоков для <ShortLogo>, использовать один, а класс цвета текста определять с помощью переменной. Пример: const logoColorClass = isMenuOpen ? 'text-[#6B80C5]' : 'text-[#E6E7EE]';.
Цель: Устранить дублирование кода и сделать логику рендеринга более декларативной и чистой.
65. Анализ FooterContext.tsx:
Контекст: Компонент является эталонной, чистой и безопасной реализацией паттерна React Context для решения конкретной задачи. Он идеально подходит для своей цели и следует всем лучшим практикам.
Задачи: На данный момент улучшений не требуется. Компонент является образцовой реализацией.
Статус: Завершено / Не требуется.
66. Улучшения CookieConsentBanner.tsx:
Контекст: Компонент является образцовой реализацией самодостаточного виджета, который корректно использует localStorage для персистентности. Его основные недостатки — использование "магических строк" и чисел, что противоречит архитектурным принципам проекта.
Задачи:
[Refactoring] Централизовать ключ для localStorage:
План: Вынести строку 'cookie_consent_given' в глобальный файл с константами (например, /src/config/constants.ts).
Цель: Создать единый источник правды для ключей localStorage, устранить "магические строки" и повысить поддерживаемость.
[Architecture] Применить централизованную систему z-index и навигации:
План:
Заменить z-[200] на семантический класс из tailwind.config.ts.
Заменить жестко закодированный href на значение из файла /src/config/navigation.ts.
Цель: Обеспечить полную архитектурную консистентность с другими компонентами проекта.
[Legal/UX] Рассмотреть добавление кнопки "Отклонить":
План: Провести аудит на соответствие требованиям GDPR и другим законам о конфиденциальности. Если необходимо, добавить кнопку "Отклонить" и реализовать логику для обработки этого выбора (например, отключение скриптов аналитики).
Цель: Обеспечить юридическую состоятельность и предоставить пользователю больший контроль.
67. Улучшения CatalogContent.tsx:
Контекст: Компонент является образцовым "Dumb Component", но имеет критический недостаток в виде отсутствия обработки "пустого состояния", что приводит к плохому UX.
Задачи:
[UX/High Priority] Реализовать UI для "Пустого состояния":
План: Добавить в начало компонента проверку: if (products.length === 0) { ... }. Если товаров нет, рендерить специальный блок с сообщением для пользователя (например, "Товары не найдены" или "В этой категории пока ничего нет").
Цель: Улучшить пользовательский опыт, предоставляя ясную обратную связь вместо пустой страницы.
[Architecture/Refactoring] Провести аудит и рефакторинг пропа isLoading:
План: Проанализировать, является ли проп isLoading артефактом или заготовкой.
Если артефакт: Удалить проп и связанную с ним логику прозрачности, полностью полагаясь на Next.js Suspense.
Если заготовка: Оставить проп, но добавить комментарий, объясняющий, что он предназначен для будущей клиентской фильтрации.
Цель: Устранить потенциально "мертвый" код и сделать намерения разработчика более ясными.
68. Улучшения ProductCard.tsx:
Контекст: Компонент является высококачественным UI-элементом с надежной обработкой изображений и событий. Его главный архитектурный недостаток — чисто клиентская реализация "избранного", которая не синхронизируется с аккаунтом пользователя.
Задачи:
[Feature/Architecture/High Priority] Интегрировать "Избранное" с бэкендом:
План: Рефакторить логику "лайков". Для авторизованных пользователей состояние isLiked должно читаться из данных пользователя (из WishlistItem в БД), а клик по кнопке должен вызывать Server Action для добавления/удаления товара из избранного. Для неавторизованных пользователей можно оставить текущую логику с localStorage как fallback.
Цель: Создать единую, персистентную и синхронизируемую между устройствами систему "Избранного".
[Refactoring/Design System] Устранить жестко закодированный цвет:
План: Добавить цвет #D32F2F в палитру tailwind.config.ts под семантическим именем (например, colors.feedback.love или colors.accent.red). Заменить inline-стиль на соответствующий utility-класс Tailwind (например, text-feedback-love).
Цель: Обеспечить 100% соответствие принципу единой дизайн-системы.
[Refactoring] Централизовать ключ для localStorage:
План: Вынести префикс 'liked-' в глобальный файл с константами, как это было предложено для других подобных ключей.
Цель: Устранить "магические строки" и повысить поддерживаемость.
69. Улучшения CategoryFilter.tsx:
Контекст: Компонент является архитектурно сложным и элегантным решением для синхронизации UI. Его реализация почти безупречна. Задачи направлены на доведение его до полного соответствия принципам дизайн-системы и DRY.
Задачи:
[Refactoring/Design System] Устранить inline-стиль:
План: Заменить жестко закодированный style для активного элемента на utility-классы Tailwind. Цвет #272727 уже существует в палитре как text-gray-800 или bg-gray-800. Высоту можно задать через класс h-[1.5px].
Цель: Обеспечить 100% управление стилями через централизованную дизайн-систему.
[Refactoring] Централизовать ключ для localStorage:
План: Вынести строку 'activeCategory' в глобальный файл с константами, как это было предложено для других подобных ключей.
Цель: Устранить "магические строки" и повысить поддерживаемость.
[Documentation] Добавить JSDoc-комментарии:
План: Добавить подробные JSDoc-комментарии, объясняющие сложную архитектуру "Марионетка/Кукловод" и назначение каждого "командного" пропа (scrollLeft, onScroll, disableCentering).
Цель: Сделать сложную логику компонента понятной для любого разработчика в будущем, обеспечив его долгосрочную поддерживаемость.
Роадмап для src/components/SmartStickyCategoryFilter.tsx
Принято. Добавляю пункт в глобальный роадмап.
70. Улучшения SmartStickyCategoryFilter.tsx:
Контекст: Компонент является архитектурно сложным и умным "кукловодом", но страдает от критической сломанной зависимости, которая была "залатана" магическим числом, и дублирует логику анимации.
Задачи:
[Architecture/High Priority] Устранить сломанную зависимость и жестко закодированную высоту:
План: Полностью удалить "магическое число" const topOffset = 64;. Реализовать логику для чтения CSS-переменной --header-height из DOM (как было предложено для SearchOverlay) и передавать это динамическое значение в хук useSmartSticky.
Цель: Восстановить архитектурную целостность, сделать компонент по-настоящему адаптивным и устранить самый серьезный технический долг.
[Refactoring/DRY] Инкапсулировать логику анимации монтирования в кастомный хук:
План: Логика в useEffect, управляющая isMounted и isAnimating, является почти точной копией логики из SearchOverlay.tsx. Необходимо вынести эту логику в новый переиспользуемый кастомный хук, например useAnimatedMount({ isVisible, duration }).
Цель: Устранить дублирование кода (DRY) и сделать сложную логику анимации переиспользуемой и легко управляемой.
[Documentation] Добавить JSDoc-комментарии:
План: Добавить подробные комментарии, объясняющие паттерн "Кукловод/Марионетки" и механизм синхронизации scrollLeft.
Цель: Сделать сложную архитектуру компонента понятной для будущей поддержки.
Роадмап для src/components/hooks/useSmartSticky.ts
Принято. Добавляю пункт в глобальный роадмап.
71. Улучшения хука useSmartSticky.ts:
Контекст: Хук является архитектурно сложным и элегантным произведением, демонстрирующим образцовую композицию хуков. Однако он содержит критический "code smell" в виде рекурсивного массива зависимостей useEffect, что может привести к нестабильной работе.
Задачи:
[Bug/High Priority] Устранить рекурсивную зависимость в useEffect:
План: Провести рефакторинг useEffect. Извлечь setter-функции (setIsVisible, setIsTransitionEnabled) из зависимости. Модифицировать вызовы так, чтобы они использовали функциональное обновление (setIsVisible(prev => !prev)), если это необходимо, или перестроить логику, чтобы избежать зависимости от предыдущего значения состояния внутри эффекта.
Цель: Обеспечить стабильную и предсказуемую работу хука, устранив риск возникновения бесконечных циклов ререндеринга.
[Refactoring] Улучшить читаемость логических правил:
План: Вынести сложные условия из useEffect в отдельные, именованные булевы переменные. Пример: const isAtStickingPoint = targetRect.top >= headerHeight;.
Цель: Сделать основной useEffect более декларативным и легким для понимания, превратив его в последовательность легко читаемых правил.
73. Улучшения хука-информатора о скролле (useScrollInfo.ts):
Контекст: Хук выполняет свою задачу, но его реализация содержит критические недостатки производительности из-за неоптимального использования useState и отсутствия throttle для обработчика скролла.
Задачи:
[Performance/High Priority] Заменить useState на useRef для lastScrollY:
План: Рефакторить хук, заменив const [lastScrollY, setLastScrollY] = useState(0) на const lastScrollY = useRef(0). Удалить lastScrollY из массива зависимостей useEffect, оставив его пустым.
Цель: Устранить избыточные ререндеры и ненужные перезапуски useEffect, что является ключевой оптимизацией.
[Performance/High Priority] Оптимизировать обработчик скролла:
План: "Обернуть" функцию handleScroll в throttle или, что еще лучше, в requestAnimationFrame. Это сгруппирует вызовы setScrollInfo и будет выполнять их не чаще, чем браузер может отрисовать кадр.
Цель: Радикально снизить количество ререндерингов во время активной прокрутки, что предотвратит "тормоза" и повысит общую производительность.
74. Улучшения ProductDetails.tsx:
Контекст: Компонент является классическим "God Component", который концентрирует в себе слишком много логики, что усложняет его поддержку. Он также содержит статичные макеты и временные "хаки".
Задачи:
[Architecture/High Priority] Рефакторинг "God Component" с помощью кастомного хука:
План: Создать новый кастомный хук, например, useProductDetailsState(product). Вынести в этот хук всю логику из ProductDetails: все useState, useEffect и все функции-обработчики (handleSelectSize, handleAddToCart и т.д.). Компонент ProductDetails должен будет только вызывать этот хук и передавать возвращенные им значения и функции в дочерние компоненты.
Цель: Радикально упростить компонент ProductDetails, превратив его в чистый "оркестратор". Это повысит читаемость, тестируемость и отделит логику управления состоянием от представления.
[Feature/High Priority] Устранить жестко закодированные данные в MobileSizeGuideWithAccordion:
План: Рефакторить MobileSizeGuideWithAccordion, чтобы он получал данные о размерах через пропсы. Эти данные должны браться из product или передаваться с более высокого уровня.
Цель: Превратить статический макет в динамический, data-driven компонент.
[Cleanup/High Priority] Удалить временный "хак":
План: Удалить строку <div className="h-[200vh] bg-white" /> из JSX.
Цель: Очистить код от временных артефактов разработки.
[Refactoring/Code Quality] Модуляризовать внутренние компоненты:
План: Вынести локально определенные компоненты (CountdownTimer, MobileSizeGuideWithAccordion, ProductInfoBlock) в их собственные файлы в директории /src/components/product-details/.
Цель: Улучшить структуру проекта и следовать принципу "один компонент — один файл".
75. Улучшения MobileProductGallery.tsx:
Контекст: Компонент является сложной и продуманной оберткой над Swiper.js, которая реализует продвинутый UX. Его основные недостатки — хрупкое управление стилями и использование "магических" значений.
Задачи:
[Refactoring/Design System] Устранить жестко закодированные стили:
План: Заменить все жестко закодированные значения цветов и размеров в кастомной пагинации (например, bg-[#272727], h-1, w-5) на utility-классы Tailwind. Недостающие значения должны быть добавлены в tailwind.config.ts.
Цель: Обеспечить 100% соответствие принципу единой дизайн-системы и упростить управление стилями.
[Refactoring/Architecture] Сделать управление z-index более декларативным:
План: Исследовать возможность управления z-index через CSS-классы и состояние React вместо прямого манипулирования DOM-стилями. Например, можно хранить zoomedSlideId в состоянии и применять класс z-50 к слайду, id которого совпадает.
Цель: Уменьшить количество императивного кода, сделать логику более предсказуемой и менее зависимой от внутренней структуры Swiper.
[Code Quality] Улучшить типизацию Swiper Instance:
План: Уточнить тип useState<SwiperInstance | null>. Хотя SwiperInstance уже используется, нужно убедиться, что он импортируется из swiper/types и покрывает все используемые методы (zoom, slideNext и т.д.), чтобы избежать любых неявных any.
Цель: Обеспечить максимальную типобезопасность при взаимодействии с API библиотеки.
76. Улучшения DesktopProductGallery.tsx:
Контекст: Компонент является отличной реализацией сложного паттерна "Thumbs gallery", но нарушает архитектурную конвенцию проекта по использованию иконок и использует хрупкий механизм связи для навигации.
Задачи:
[Architecture/High Priority] Заменить иконки из @heroicons на локальные:
План: Создать в директории /src/components/icons собственные компоненты для ChevronLeftIcon и ChevronRightIcon, скопировав их SVG-код. Заменить импорт из @heroicons/react на импорт этих локальных компонентов.
Цель: Обеспечить 100% консистентность в управлении иконками, устранить ненужную внешнюю зависимость и следовать архитектурным правилам проекта.
[Refactoring/Reliability] Рефакторинг навигации на useRef:
План: Вместо использования строковых классов, создать два useRef для кнопок-стрелок. Передать эти ref в JSX кнопок, а затем в опции navigation Swiper передать navigation={{ nextEl: nextButtonRef.current, prevEl: prevButtonRef.current }} внутри useEffect или onSwiper.
Цель: Сделать связь между Swiper и его кнопками навигации типобезопасной и надежной, устранив хрупкость строковых селекторов.
77. Улучшения ProductHeader.tsx:
Контекст: Компонент является образцовым "Dumb Component", но нарушает архитектурные принципы проекта, используя жестко закодированные цвета и локальную функцию-форматтер.
Задачи:
[Architecture/High Priority] Централизовать утилиту formatBonusPoints:
План: Переместить функцию formatBonusPoints из этого файла в глобальный файл утилит /src/utils/formatPrice.ts. Компонент должен будет импортировать ее оттуда.
Цель: Обеспечить строгое разделение ответственности (компонент отвечает за UI, утилита — за форматирование данных) и следовать принципу DRY.
[Refactoring/Design System] Устранить жестко закодированные цвета:
План: Заменить все жестко закодированные HEX-цвета (для бейджа бонусов и скидки) на соответствующие семантические классы из tailwind.config.ts (например, bg-brand-lilac/10, text-brand-lilac, bg-feedback-error).
Цель: Обеспечить 100% соответствие принципу единой дизайн-системы.
78. Улучшения AddToCartButton.tsx:
Контекст: Компонент является образцовым "Dumb Component", но нарушает архитектурные конвенции проекта, используя жестко закодированные цвета и локально определенные иконки.
Задачи:
[Architecture/High Priority] Централизовать компоненты иконок:
План: Переместить локально определенные компоненты MinusIcon и PlusIcon в их собственные файлы в общую директорию /src/components/icons/.
Цель: Обеспечить строгую архитектурную консистентность и переиспользуемость иконок.
[Refactoring/Design System] Устранить жестко закодированные цвета:
План: Заменить все жестко закодированные HEX-цвета на соответствующие семантические классы из tailwind.config.ts (например, bg-brand-lilac, text-text-primary, border-text-primary).
Цель: Обеспечить 100% соответствие принципу единой дизайн-системы.
79. Улучшения SizeSelector.tsx:
Контекст: Компонент является высококачественным "Dumb Component" с продвинутым "резиновым" UI. Его главный недостаток — наличие функциональной "заглушки" для фичи "Сообщить о поступлении" и использование "магических чисел".
Задачи:
[Feature/High Priority] Реализовать функционал "Сообщить о поступлении":
План: Заменить console.log в handleWishlistClick на вызов Server Action. Этот экшен должен будет сохранять в базе данных (в новой или существующей модели) информацию о том, что конкретный пользователь (userId) хочет получить уведомление о поступлении конкретного размера (productSizeId).
Цель: Превратить UI-заглушку в полноценную и ценную для бизнеса e-commerce фичу.
[Refactoring/Design System] Устранить "магические числа" и цвета:
План:
Вынести LOW_STOCK_THRESHOLD в глобальный файл конфигурации (например, /src/config/shop.ts), так как этот порог является бизнес-правилом.
Заменить жестко закодированный цвет #272727 на семантический класс из tailwind.config.ts.
Цель: Централизовать управление бизнес-правилами и обеспечить 100% соответствие дизайн-системе.
[Code Quality] Унифицировать имя пропа:
План: Переименовать проп inventory в sizes, чтобы он семантически соответствовал данным, которые передает родительский компонент ProductDetails.
Цель: Улучшить читаемость и семантическую консистентность кода.
80. Улучшения SizeChart.tsx:
Контекст: Компонент является эталонным "Dumb Component". Его единственный недостаток — нарушение принципов дизайн-системы.
Задачи:
[Refactoring/Design System] Устранить жестко закодированный цвет:
План: Заменить жестко закодированный HEX-цвет на соответствующий семантический класс из tailwind.config.ts (например, text-text-primary).
Цель: Обеспечить 100% соответствие принципу единой дизайн-системы.
81. Улучшения ProductAttributes.tsx:
Контекст: Компонент является сложным и умным виджетом с продуманным UX. Его главные недостатки — обилие "магических строк" и локально определенных компонентов, что снижает его надежность и поддерживаемость.
Задачи:
[Architecture/High Priority] Централизовать иконки и "магические строки":
План:
Переместить компоненты ChevronIcon и DescriptionChevronIcon в /src/components/icons.
Вынести все жестко закодированные ключи атрибутов ("Описание", "Артикул") и массив desiredOrder в глобальный файл конфигурации (например, /src/config/products.ts).
Цель: Устранить "магические строки" и локальные компоненты, сделав компонент более надежным, поддерживаемым и соответствующим архитектуре проекта.
[Reliability] Внедрить Zod для безопасного парсинга JSON:
План: В компоненте CompositionDisplay использовать библиотеку zod для безопасного парсинга и валидации JSON-строки. Это гарантирует, что распарсенный объект имеет ожидаемую структуру ([{ material: string, percentage: string }]).
Цель: Сделать рендеринг состава товара абсолютно надежным и устойчивым к некорректным данным.
[Refactoring/Design System] Устранить жестко закодированные цвета:
План: Заменить все жестко закодированные цвета на семантические классы из tailwind.config.ts.
Цель: Обеспечить 100% соответствие дизайн-системе.
82. Улучшения ProductActions.tsx:
Контекст: Компонент отлично реализует функцию "Поделиться", но его функция "Избранное" является нефункциональным макетом, который создает серьезную архитектурную неконсистентность.
Задачи:
[Architecture/High Priority] Унифицировать логику "Избранного":
План: Полностью удалить локальное состояние isLiked. Компонент должен принимать через пропсы ID продукта и его текущий статус "в избранном". Клик по кнопке должен вызывать единый Server Action, который мы определили в задаче №68 для ProductCard.
Цель: Устранить третью, нерабочую реализацию "Избранного" и интегрировать этот компонент в единую, бэкенд-управляемую систему.
[Refactoring/Design System] Устранить inline-стиль и жестко закодированные цвета:
План: Заменить inline-стиль для HeartIcon на семантические utility-классы из tailwind.config.ts, как это было предложено для ProductCard.
Цель: Обеспечить 100% соответствие дизайн-системе.
[UX] Улучшить fallback для функции "Поделиться":
План: Заменить грубый alert() на более элегантное решение. Например, при отсутствии navigator.share можно копировать URL в буфер обмена (navigator.clipboard.writeText) и показывать пользователю уведомление "Ссылка скопирована" через централизованную систему showNotification.
Цель: Улучшить пользовательский опыт на браузерах, не поддерживающих Web Share API.
83. Улучшения DesktopActionButtons.tsx:
Контекст: Компонент реализует образцовую логику для кнопки "Назад", но содержит критические архитектурные проблемы: четвертую нерабочую реализацию "Избранного", жестко закодированное позиционирование и дублирование кода.
Задачи:
[Architecture/Highest Priority] Унифицировать логику "Избранного" и "Поделиться":
План: Создать единый кастомный хук, например useProductActions(productId). В этот хук вынести всю логику:
Унифицированную, бэкенд-управляемую логику "Избранного" (из задачи №68).
Унифицированную логику "Поделиться" (из задачи №82).
ProductActions и DesktopActionButtons должны будут оба использовать этот хук, превратившись в чисто презентационные компоненты.
Цель: Устранить все дублирующиеся и неконсистентные реализации, создав единый, надежный и DRY-совместимый источник правды для всех действий с товаром.
[Architecture/High Priority] Устранить жестко закодированное позиционирование:
План: Заменить top-[105px] на top-[var(--header-height)]. Компонент будет динамически считывать высоту хедера из той же CSS-переменной, которую устанавливает HybridHeader.
Цель: Создать надежную и адаптивную связь с хедером, устранив "магическое число".
[Architecture/Refactoring] Централизовать компоненты иконок:
План: Переместить локально определенные иконки BackArrowIcon и ShareIcon в общую директорию /src/components/icons/.
Цель: Обеспечить строгую архитектурную консистентность.
84. Улучшения BottomSheet.tsx:
Контекст: Компонент является технически сложной и хорошо реализованной имитацией нативного UI, но страдает от дублирования критической логики и серьезных недостатков в области доступности (a11y).
Задачи:
[Architecture/Highest Priority] Унифицировать логику блокировки скролла:
План: Эта задача полностью совпадает с задачей №63. Необходимо вынести дублирующуюся логику блокировки скролла в единый кастомный хук useBodyScrollLock(isLocked). BottomSheet должен будет использовать этот хук вместо собственной реализации useEffect.
Цель: Устранить дублирование кода и создать единый, надежный механизм блокировки скролла.
[Accessibility/High Priority] Реализовать доступность (a11y) для модального окна:
План:
Добавить к корневому элементу атрибуты role="dialog" и aria-modal="true".
Добавить useEffect для подписки на событие keydown. При нажатии на клавишу Escape, если isOpen, вызывать onClose().
Цель: Сделать компонент полностью доступным и соответствующим стандартам WAI-ARIA для модальных диалогов.
[Refactoring] Устранить "магические числа":
План: Вынести SWIPE_THRESHOLD_PERCENTAGE в именованную константу. Заменить z-[100] на семантический класс из tailwind.config.ts.
Цель: Повысить читаемость и поддерживаемость кода.
85. Улучшения Button.tsx:
Контекст: Компонент содержит критический архитектурный антипаттерн, смешивая обязанности UI-примитива с глобальной бизнес-логикой ("умный" примитив). Это нарушает принцип единственной ответственности и снижает переиспользуемость.
Задачи:
[Architecture/Highest Priority] Рефакторинг в чистый "Dumb Component":
План:
Полностью удалить импорт useAppStore и всю связанную с ним логику из handleClick.
Удалить внутреннее состояние isLoading. Вместо этого компонент должен принимать isLoading: boolean как проп.
Упростить handleClick до прямого вызова onClick(event).
Перенести логику проверки isOnline на уровень выше — в те компоненты-контроллеры (например, формы), которые используют эту кнопку для выполнения сетевых запросов.
Цель: Превратить компонент в настоящий, предсказуемый и универсально переиспользуемый UI-примитив, восстановив правильное разделение ответственности.
[Architecture/Refactoring] Централизовать иконки:
План: Переместить SpinnerIcon и WifiSlashIcon в /src/components/icons.
Цель: Обеспечить архитектурную консистентность.
[Refactoring/Design System] Устранить жестко закодированные цвета:
План: Заменить все HEX-цвета в variantClasses на семантические классы из tailwind.config.ts.
Цель: Обеспечить 100% соответствие дизайн-системе.
86. Улучшения useAppStore.ts:
Контекст: Хранилище является хорошо организованным "мозгом" приложения, но содержит критический архитектурный антипаттерн в виде управления побочным эффектом через глобальную переменную, а также является монолитным.
Задачи:
[Architecture/High Priority] Рефакторинг побочного эффекта для уведомлений:
План:
Удалить notificationTimeout и всю логику setTimeout/clearTimeout из showNotification. Экшен должен просто устанавливать состояние видимости.
Перенести логику setTimeout в компонент NotificationManager.tsx. Внутри него создать useEffect, который будет "слушать" изменение notification.isVisible. Если оно стало true, useEffect должен запустить таймер, который по истечении времени вызовет hideNotification().
Цель: Достичь чистого разделения ответственности: хранилище отвечает только за состояние, а компонент-представление — за побочные эффекты, связанные с его жизненным циклом.
[Architecture] Разделение монолитного стора на "слайсы":
План: В будущем, по мере роста проекта, рефакторить текущий стор, используя официальный паттерн Zustand для "слайсов". Создать отдельные функции-фабрики для каждого домена (createNotificationSlice, createUserSlice и т.д.) в отдельных файлах, а затем объединить их в корневом useAppStore.
Цель: Повысить модульность, масштабируемость и поддерживаемость глобального состояния.
[Refactoring] Устранить "магическое число":
План: Вынести значение 3000 в именованную константу (например, NOTIFICATION_DISPLAY_DURATION).
Цель: Улучшить читаемость и упростить настройку.
87. Улучшения auth.ts:
Контекст: Файл является архитектурно сложным и мощным ядром системы аутентификации. Его реализация практически безупречна, за исключением одного "code smell", связанного с типизацией.
Задачи:
[Code Quality/High Priority] Устранить использование any в callbacks:
План: Модифицировать файл src/types/next-auth.d.ts, чтобы расширить стандартные интерфейсы User, JWT и Session из next-auth, добавив в них кастомные поля (id, role, bonusPoints, emailVerified). После этого удалить все приведения типов (user as any).
Цель: Достичь полной типобезопасности во всем потоке аутентификации, улучшить автодополнение и надежность кода.
88. Анализ encryption.ts:
Контекст: Файл является образцовой реализацией криптографического модуля. Он следует лучшим практикам безопасности (server-only, fail-fast) и корректно применяет криптографические алгоритмы для разных задач.
Задачи: На данный момент серьезных улучшений не требуется. Реализация является надежной, безопасной и соответствует самым высоким стандартам.
Статус: Завершено / Не требуется.
89. Улучшения moysklad-api.ts:
Контекст: Модуль является мощным и хорошо спроектированным "Антикоррупционным слоем", но содержит критическую уязвимость безопасности из-за отсутствия гарантии выполнения только на сервере, а также страдает от отсутствия строгой типизации.
Задачи:
[Security/Highest Priority] Внедрить import 'server-only':
План: Добавить строку import 'server-only'; в самое начало файла.
Цель: Создать непробиваемый барьер на уровне сборки, который гарантирует, что этот файл и содержащиеся в нем секреты никогда не смогут попасть в клиентский код.
[Code Quality/High Priority] Внедрить строгую типизацию для ответов API:
План: Создать в директории /src/types или /src/lib/types файлы с интерфейсами TypeScript, описывающими ключевые сущности "МоегоСклада" (например, MoySkladProduct, MoySkladVariant, MoySkladStock). Заменить все использования any на эти строгие типы.
Цель: Обеспечить полную типобезопасность при работе с внешним API, предотвратить ошибки времени выполнения и улучшить Developer Experience (автодополнение).
[Refactoring/DRY] Унифицировать логику кэширования:
План: Создать небольшую универсальную функцию-обертку, например createCachedGetter(fetchFunction), которая инкапсулирует паттерн "проверить кэш -> если нет, выполнить функцию и сохранить в кэш". Использовать ее для getMoySkladApiKey, getMoySkladDefaultRefs и т.д.
Цель: Устранить дублирование кода и сделать логику кэширования более декларативной.
90. Улучшения mail.ts:
Контекст: Модуль является хорошим "фасадом" для отправки email, но содержит критическую уязвимость безопасности и страдает от значительного дублирования кода в HTML-шаблонах.
Задачи:
[Security/Highest Priority] Внедрить import 'server-only':
План: Добавить строку import 'server-only'; в самое начало файла.
Цель: Гарантировать на уровне сборки, что секретные креды от почтового сервера никогда не попадут в клиентский код.
[Architecture/High Priority] Внедрить систему шаблонизации email:
План: Рефакторить модуль, отделив "данные" от "представления".
Создать базовый HTML-шаблон (функцию или компонент), который принимает title, body и т.д.
Каждая функция (sendPasswordResetEmail) должна будет только подготавливать специфичный для нее контент и передавать его в этот общий шаблон.
Продвинутый вариант: Рассмотреть использование специализированной библиотеки для рендеринга email, такой как react-email, которая позволяет создавать письма как React-компоненты.
Цель: Устранить дублирование кода (DRY) и создать масштабируемую, легко поддерживаемую систему для управления email-шаблонами.
[Refactoring] Централизовать тексты и URL:
План: Вынести темы и тексты писем в отдельный файл с константами или систему локализации (i18n), если планируется поддержка нескольких языков. URL для сброса пароля должен собираться с использованием централизованных констант путей.
Цель: Упростить управление контентом писем и повысить поддерживаемость.
91. Улучшения telegram.ts:
Контекст: Файл является архитектурно сложным и мощным бэкендом для ботов, использующим продвинутые паттерны (middleware, временное состояние в БД). Однако он содержит критическую уязвимость безопасности и критическое нарушение принципа DRY.
Задачи:
[Architecture/Highest Priority] Устранить дублирование логики отправки email:
План: Полностью удалить nodemailer из этого файла. Вместо этого, импортировать и использовать существующие функции из /src/lib/mail.ts. Если потребуется новая функция для отправки ответа агента, она должна быть добавлена в mail.ts и вызываться оттуда.
Цель: Создать единый, DRY-совместимый источник правды для всей логики отправки email в приложении.
[Security/Highest Priority] Внедрить import 'server-only':
План: Добавить import 'server-only'; в самое начало файла.
Цель: Гарантировать, что секретные токены ботов и логика их бэкенда никогда не попадут в клиентский код.
[Code Quality/High Priority] Устранить использование any:
План: Расширить стандартный интерфейс Context из telegraf, добавив в него опциональное поле agent: SupportAgent. Создать кастомный типизированный контекст и использовать его во всех middleware и обработчиках supportBot.
Цель: Достичь полной типобезопасности при работе с обогащенным контекстом.
92. Улучшения session.ts:
Контекст: Файл реализует параллельную, кастомную систему сессий, что является важным, но пока не до конца понятным архитектурным решением. Реализация содержит критическую уязвимость безопасности и "code smells".
Задачи:
[Architecture/Highest Priority] Провести аудит назначения кастомной сессии:
План: Найти в кодовой базе все места, где вызываются функции encrypt и decrypt из этого модуля. Определить, для чего используется эта вторая система сессий.
Цель: Понять архитектурный замысел. Если эта система является артефактом или может быть заменена стандартным механизмом NextAuth.js, ее следует удалить, чтобы упростить архитектуру. Если же она выполняет важную, уникальную роль (например, аутентификация API), это необходимо четко задокументировать.
[Security/High Priority] Внедрить import 'server-only':
План: Добавить import 'server-only'; в самое начало файла.
Цель: Гарантировать, что AUTH_SECRET и логика работы с JWT никогда не попадут в клиентский код.
[Code Quality/High Priority] Устранить any и "магические строки":
План:
Заменить payload: any на строго типизированный интерфейс (например, CustomSessionPayload), описывающий данные, которые могут храниться в этом токене.
Вынести имя cookie 'session' в централизованный файл с константами.
Цель: Обеспечить типобезопасность и повысить поддерживаемость кода.
93. Улучшения types.ts:
Контекст: Файл является попыткой создать централизованный "словарь типов", но эта практика не применяется консистентно во всем проекте, что приводит к дублированию типов и рассинхронизации.
Задачи:
[Architecture/Highest Priority] Провести глобальный рефакторинг и централизацию типов:
План:
Провести полный аудит кодовой базы и найти все локально определенные интерфейсы и типы, которые описывают данные из schema.prisma (например, UserSession, InventoryItem, Attribute).
Переместить все эти определения в types.ts, унифицировав их имена и структуру.
Заменить все локальные определения в компонентах на импорты из этого центрального файла.
Цель: Превратить этот файл в настоящий и единственный источник правды для всех кастомных типов данных в приложении, что радикально повысит надежность и поддерживаемость.
[Code Quality] Использовать Prisma.TypeGetPayload для большей точности:
План: Рефакторить существующие типы, такие как UpdateProductPayload, используя Prisma.TypeGetPayload (как это сделано в ProductDetails.tsx). Это позволяет генерировать типы, которые автоматически включают все необходимые связи (include), и они будут автоматически обновляться при изменении schema.prisma.
Цель: Устранить необходимость ручной поддержки типов и сделать их на 100% синхронизированными со схемой БД.
94. Анализ utils.ts:
Контекст: Файл предоставляет каноническую, общепринятую и безупречно реализованную утилиту cn для работы с классами Tailwind CSS.
Задачи: На данный момент улучшений не требуется. Реализация является эталонной.
Статус: Завершено / Не требуется.
95. Улучшения AdminLayout.tsx:
Контекст: Компонент является образцовой реализацией паттерна "Серверный Охранник", обеспечивая максимальную безопасность админ-панели. Его единственный недостаток — использование "магических строк" для определения ролей.
Задачи:
[Architecture/Refactoring] Устранить "магические строки" для ролей:
План: Если в schema.prisma для ролей используется enum, необходимо импортировать этот enum и использовать его значения ([Role.ADMIN, Role.MANAGEMENT]). Если enum'а нет, следует вынести массив ADMIN_ROLES в централизованный файл конфигурации прав доступа (например, /src/config/permissions.ts).
Цель: Создать единый источник правды для названий ролей, устранить риск ошибок из-за опечаток и сделать систему более надежной и поддерживаемой.
96. Улучшения AdminHeader.tsx:
Контекст: Компонент является хорошо спроектированным, самодостаточным навигационным элементом, но страдает от критической проблемы с жестко закодированными URL и нарушает принцип централизации конфигурации.
Задачи:
[Architecture/Highest Priority] Централизовать навигационную структуру:
План: Переместить массив adminNavLinks из этого файла в центральный файл конфигурации /src/config/navigation.ts, который мы уже определили в предыдущих задачах.
Цель: Создать единый источник правды для всех навигационных структур в приложении, следуя принципу DRY.
[Refactoring/High Priority] Устранить жестко закодированные URL:
План: Заменить все абсолютные URL на значения из переменных окружения (process.env.NEXT_PUBLIC_BASE_URL).
Цель: Обеспечить переносимость и корректную работу компонента во всех окружениях (development, staging, production).
Роадмап для src/app/admin/dashboard/page.tsx
Принято. Добавляю пункт в глобальный роадмап.
97. Улучшения DashboardPage:
Контекст: Компонент является образцовой реализацией "кухни" для серверного получения данных. Он производителен и использует продвинутую типизацию. Его единственный недостаток — "дыра" в системе типов.
Задачи:
[Code Quality/High Priority] Устранить использование any:
План: Провести аудит типов. Определить, почему тип filterPresets, возвращаемый Prisma, несовместим с тем, что ожидает ProductTable. Создать или исправить тип (вероятно, в /src/lib/types.ts) так, чтобы он точно описывал структуру FilterPreset с включенными связями (items, category, tag). Удалить приведение as any.
Цель: Восстановить полную типобезопасность при передаче данных между серверными и клиентскими компонентами.
98. Улучшения ProductTable.tsx:
Контекст: Компонент является хорошо спроектированным "оркестратором", который правильно управляет состоянием и делегирует рендеринг. Его единственный недостаток — локальное определение сложного типа.
Задачи:
[Architecture/Refactoring] Централизовать тип FilterPresetWithItems:
План: Переместить определение типа FilterPresetWithItems из этого файла в центральный файл /src/lib/types.ts.
Цель: Завершить централизацию типов, следовать принципу DRY и сделать этот сложный тип переиспользуемым для других возможных компонентов.
[Future/Feature] Реализовать клиентскую фильтрацию и сортировку:
План: В будущем этот компонент станет "умнее". Он будет использовать useState для хранения отфильтрованного/отсортированного списка продуктов. DashboardControls будет сообщать ему, как нужно изменить этот список.
Цель: Превратить статичную таблицу в полностью интерактивный инструмент для работы с данными.
99. Улучшения ProductTableRow.tsx:
Контекст: Компонент является сложным, многофункциональным "сердцем" таблицы продуктов, который отлично реализует паттерны "Master-Detail" и "Inline Editing". Его главные недостатки — серьезное нарушение принципа DRY и архитектурная неконсистентность в подходе к мутациям.
Задачи:
[Architecture/Highest Priority] Централизовать утилиты форматирования:
План: Переместить локальные функции formatPrice и formatArticle в соответствующие глобальные файлы утилит (например, /src/utils/formatPrice.ts).
Цель: Устранить критическое дублирование кода (DRY), создать единый источник правды для логики форматирования и повысить поддерживаемость.
[Architecture/High Priority] Мигрировать мутации на Server Actions:
План: Рефакторить функции handleCategoryChange и handleDelete. Заменить fetch-запросы к API Routes на вызовы соответствующих Server Actions. router.refresh() можно будет заменить на revalidatePath().
Цель: Унифицировать архитектуру мутаций во всем приложении, приведя ее в соответствие с современным паттерном Server Actions, и уменьшить количество API-маршрутов.
[Refactoring] Сделать хук useCopyToClipboard переиспользуемым:
План: Переместить хук useCopyToClipboard из этого файла в общую директорию для хуков (например, /src/hooks/useCopyToClipboard.ts).
Цель: Превратить локальную утилиту в глобальный, переиспользуемый инструмент.
100. Улучшения VariantRow.tsx:
Контекст: Компонент является важным звеном в иерархии "Master-Detail", но страдает от критического дублирования кода и других "code smells", унаследованных от своего родителя.
Задачи:
[Architecture/Highest Priority] Устранить дублирование кода (DRY):
План:
Удалить локальную копию хука useCopyToClipboard и импортировать его из централизованного расположения (согласно задаче №99).
Удалить локальную копию утилиты formatPrice и импортировать ее из /src/utils/formatPrice.ts (согласно задаче №99).
Цель: Решить системную проблему дублирования кода в модуле, следуя принципу DRY.
[Architecture/High Priority] Централизовать бизнес-логику getColorCode:
План: Переместить функцию getColorCode из этого файла в соответствующий серверный модуль с бизнес-логикой (например, /src/lib/sku-generator.ts).
Цель: Отделить представление от бизнес-логики и сделать эту логику переиспользуемой.
[Code Quality/High Priority] Устранить as any:
План: Провести аудит типов. Определить, почему тип sizeInfo несовместим с тем, что ожидает ProductSizeRow. Исправить тип VariantWithDetails или пропсы ProductSizeRow для достижения полной типобезопасности.
Цель: Восстановить целостность системы типов.
101. Улучшения ProductSizeRow.tsx:
Контекст: Компонент является мощнейшим инструментом для inline-редактирования, но страдает от критического дублирования кода и чрезмерной сложности в управлении состоянием.
Задачи:
[Architecture/Highest Priority] Устранить дублирование кода (DRY):
План: Эта задача полностью совпадает с задачей №100. Необходимо удалить локальные копии useCopyToClipboard и formatPrice и импортировать их из централизованных модулей.
Цель: Окончательно решить системную проблему дублирования кода в модуле /product-table.
[Architecture/High Priority] Мигрировать мутации на Server Actions:
План: Рефакторить handleStockSave и handlePriceSave для использования Server Actions вместо fetch к API Routes.
Цель: Унифицировать архитектуру мутаций.
[Refactoring/Code Quality] Рефакторинг управления состоянием цен на useReducer:
План: Заменить пять useState, управляющих ценами и режимом редактирования, на один useReducer. Создать редюсер, который будет обрабатывать экшены ('UPDATE_PRICE', 'UPDATE_DISCOUNT', 'CANCEL') и возвращать новое, консистентное состояние.
Цель: Сделать сложную, взаимосвязанную логику управления состоянием более предсказуемой, надежной, тестируемой и легкой для понимания.
102. Улучшения DashboardControls.tsx:
Контекст: Компонент является мощным, но чрезвычайно сложным "пультом управления", который страдает от критического дублирования кода из-за отсутствия абстракции для асинхронных операций.
Задачи:
[Architecture/Highest Priority] Рефакторинг асинхронных операций с помощью кастомного хука:
План: Создать новый кастомный хук, например useApiAction(apiFunction, options). Этот хук будет инкапсулировать всю шаблонную логику:
Принимать функцию, которая выполняет fetch.
Управлять состоянием isLoading.
Автоматически показывать toast.loading, toast.success, toast.error.
Автоматически вызывать router.refresh() в случае успеха.
Вместо 5 useState и 5 одинаковых try/catch блоков, в компоненте останется 5 вызовов этого хука. Пример: const { execute: handleSync, isLoading: isSyncing } = useApiAction(syncApiCall);.
Цель: Радикально сократить и упростить код (DRY), сделав его более декларативным, надежным и легким для поддержки.
[Architecture/High Priority] Мигрировать мутации на Server Actions:
План: В рамках предыдущего рефакторинга, заменить fetch-запросы на вызовы соответствующих Server Actions. Кастомный хук должен быть спроектирован так, чтобы работать и с Server Actions.
Цель: Унифицировать архитектуру мутаций во всем приложении.
[Refactoring/Architecture] Централизовать иконки и устранить "магические" значения:
План: Переместить локальные иконки в /src/components/icons. Заменить жестко закодированные цвета на семантические классы из tailwind.config.ts.
Цель: Обеспечить консистентность с остальной частью проекта.
103. Улучшения ApiKeyModal.tsx:
Контекст: Компонент является образцовой реализацией "глупого", но умного с точки зрения UX, модального окна, построенного на @headlessui/react. Его единственные недостатки — нарушение архитектурных конвенций проекта.
Задачи:
[Architecture/High Priority] Заменить иконки из @heroicons на локальные:
План: Создать в /src/components/icons собственный компонент KeyIcon и заменить импорт из @heroicons/react.
Цель: Обеспечить 100% консистентность в управлении иконками.
[Architecture] Применить централизованную систему z-index:
План: Заменить z-30 на семантический класс из tailwind.config.ts.
Цель: Продолжить унификацию управления слоями UI.
104. Улучшения ConflictResolutionModal.tsx:
Контекст: Компонент является сложным, но хорошо спроектированным инструментом с продуманным UX и защитой от ошибок. Его основные недостатки — нарушение архитектурных конвенций (иконки, z-index) и хрупкая связь по типам с API.
Задачи:
[Architecture/High Priority] Заменить иконки из @heroicons на локальные:
План: Создать в /src/components/icons собственные компоненты для всех используемых иконок (ExclamationTriangleIcon, PlusCircleIcon и т.д.).
Цель: Обеспечить 100% консистентность в управлении иконками.
[Architecture] Централизовать типы SkuResolutionPlan и SkuConflict:
План: Переместить определения этих типов из файла API-маршрута в центральный файл /src/lib/types.ts. И API, и этот компонент должны будут импортировать их оттуда.
Цель: Создать единый, надежный источник правды для структур данных и устранить хрупкую зависимость.
[Refactoring/Design System] Применить централизованную систему z-index:
План: Заменить z-20 на семантический класс из tailwind.config.ts.
Цель: Продолжить унификацию управления слоями UI.
105. Анализ [...nextauth]/route.ts:
Контекст: Файл является канонической и архитектурно безупречной реализацией точки входа для NextAuth.js, следуя лучшей практике разделения конфигурации и логики.
Задачи: На данный момент улучшений не требуется. Реализация является эталонной.
Статус: Завершено / Не требуется.
106. Улучшения validate-credentials/route.ts:
Контекст: Эндпоинт является важным шагом кастомного флоу аутентификации и реализован безопасно, но страдает от критического дублирования основной логики аутентификации.
Задачи:
[Architecture/Highest Priority] Устранить дублирование логики аутентификации:
План: Создать новую, единую, переиспользуемую серверную функцию (например, verifyUserCredentials(email, password)) в /src/lib/auth.ts. Эта функция должна инкапсулировать всю логику: хеширование email, поиск пользователя в prisma, сравнение пароля с bcrypt.
И authorize в authOptions, и этот API-маршрут должны будут вызывать эту одну и ту же функцию.
Цель: Создать единый источник правды для логики проверки учетных данных, полностью устранить дублирование кода (DRY) и сделать систему аутентификации надежной и легко поддерживаемой.
107. Улучшения send-login-code/route.ts:
Контекст: Эндпоинт является функциональным и безопасным генератором OTP, но страдает от серьезной архитектурной проблемы — он не по назначению использует таблицу VerificationToken из схемы NextAuth.js.
Задачи:
[Architecture/High Priority] Создать выделенную таблицу для кодов входа:
План:
В файле schema.prisma создать новую модель, например LoginCode, с полями email, code, expires.
Рефакторить этот API-маршрут (и маршрут для проверки кода), чтобы он использовал эту новую, семантически корректную таблицу вместо VerificationToken.
Цель: Устранить архитектурную путаницу, предотвратить потенциальные конфликты и сделать схему данных более ясной и предсказуемой.
[Code Quality] Удалить неиспользуемый импорт:
План: Удалить import { ..., encrypt } from '@/lib/encryption';.
Цель: Поддерживать чистоту кода.
108. Улучшения verify-login-code/route.ts:
Контекст: Эндпоинт является функциональным и безопасным (благодаря удалению токена) валидатором OTP, но, как и его "брат", страдает от архитектурной проблемы с неправильным использованием таблицы VerificationToken.
Задачи:
[Architecture/High Priority] Перевести логику на выделенную таблицу LoginCode:
План: Эта задача полностью совпадает с задачей №107. После создания новой таблицы LoginCode в schema.prisma, этот эндпоинт должен быть рефакторен для работы с ней вместо VerificationToken.
Цель: Устранить архитектурную путаницу и сделать схему данных семантически корректной.
109. Улучшения register/route.ts:
Контекст: Эндпоинт является безопасным и функциональным обработчиком регистрации, но страдает от жестко закодированной конфигурации прав доступа и неполной реализации структуры данных пользователя.
Задачи:
[Architecture/High Priority] Централизовать список администраторов:
План: Переместить массив ADMIN_EMAILS из этого файла в переменные окружения. Эндпоинт должен будет читать process.env.ADMIN_EMAILS, разделять строку по запятой и использовать этот массив для проверки.
Цель: Сделать управление администраторами по умолчанию явным, централизованным и не требующим изменения кода.
[Data Integrity/High Priority] Привести API в соответствие со схемой БД:
План: Модифицировать API и фронтенд-форму регистрации. Они должны принимать и обрабатывать firstName и lastName как два отдельных поля. Эндпоинт должен шифровать и сохранять их в name_encrypted и surname_encrypted соответственно.
Цель: Обеспечить полную консистентность между данными, которые собирает UI, и структурой, определенной в schema.prisma.
Роадмап для src/app/api/auth/password-reset/request/route.ts
Принято. Добавляю пункт в глобальный роадмап.
110. Улучшения password-reset/request/route.ts:
Контекст: Эндпоинт является образцовым с точки зрения защиты от "user enumeration", но имеет архитектурный недостаток в логике управления токенами.
Задачи:
[Security/High Priority] Внедрить инвалидацию старых токенов:
План: Перед созданием нового PasswordResetToken (prisma.passwordResetToken.create), добавить шаг для удаления всех существующих токенов для данного userId: await prisma.passwordResetToken.deleteMany({ where: { userId: user.id } });.
Цель: Повысить безопасность, гарантируя, что только самая последняя ссылка для сброса пароля является валидной.
[Refactoring/Data Integrity] Устранить избыточное поле email:
План:
Удалить поле email из модели PasswordResetToken в schema.prisma и запустить миграцию.
Рефакторить этот эндпоинт, чтобы он не сохранял email в токен.
При отправке письма (sendPasswordResetEmail) email должен браться из найденного объекта user (который нужно будет расшифровать на сервере).
Цель: Нормализовать схему данных, устранить избыточность и предотвратить потенциальную рассинхронизацию.
111. Улучшения password-reset/confirm/route.ts:
Контекст: Эндпоинт является образцовым с точки зрения безопасности (использование транзакции для обновления пароля и удаления токена), но представляет собой последний элемент устаревшей архитектуры API Routes в модуле аутентификации и дублирует логику валидации пароля.
Задачи:
[Architecture/Highest Priority] Мигрировать с API Route на Server Action:
План: Полностью заменить данный API-маршрут на Server Action, который будет вызываться напрямую из компонента ResetPasswordForm.tsx. Этот экшен должен инкапсулировать всю существующую логику: проверку токена, валидацию пароля и выполнение транзакции в Prisma.
Цель: Завершить унификацию архитектуры мутаций, полностью избавившись от кастомных API-маршрутов для аутентификации в пользу Server Actions.
[Refactoring/High Priority] Централизовать логику валидации пароля:
План: Создать (или использовать существующую) Zod-схему для валидации пароля (минимальная длина, и т.д.). Эта схема должна использоваться и в Server Action для серверной валидации, и в компоненте ResetPasswordForm.tsx (через react-hook-form) для клиентской валидации.
Цель: Создать единый источник правды для правил валидации (DRY) и устранить риск рассинхронизации.
Статус: Отложено.
112. Улучшения страницы управления классификацией (categories/page.tsx):
Контекст: Компонент является образцовой "кухней", которая эффективно подготавливает данные для клиентского компонента. Его единственный, но критический недостаток — неоптимальная стратегия рендеринга force-dynamic, создающая избыточную нагрузку на базу данных.
Задачи:
[Performance/High Priority] Заменить force-dynamic на on-demand revalidation:
План: Удалить export const dynamic = 'force-dynamic';. В файле actions.ts этого же модуля (который мы проанализируем позже) необходимо будет вызывать revalidatePath('/admin/categories') после каждой успешной операции создания, обновления или удаления категории/тега.
Цель: Радикально снизить нагрузку на БД и ускорить загрузку страницы для администраторов, так как она будет пересобираться только при реальном изменении данных, а не при каждом визите.
[Refactoring] Централизовать навигационный URL:
План: Переместить жестко закодированную ссылку href="/admin/dashboard" в централизованный файл конфигурации навигации (/src/config/navigation.ts).
Цель: Обеспечить консистентность и следовать принципу DRY для всех навигационных путей.
Статус: Отложено.
113. Рефакторинг "мини-приложения" управления классификацией (ClassificationClient.tsx):
Контекст: Компонент является функционально мощным, но архитектурно проблемным "God Component". Его главные недостатки — это смешение двух подходов к мутациям (Server Actions + fetch), концентрация всей логики в одном месте и нарушение архитектурных конвенций проекта (локальные компоненты, иконки).
Задачи:
[Architecture/Highest Priority] Унифицировать все мутации на Server Actions:
План: Провести рефакторинг, заменив все fetch-запросы (/api/admin/sync/dry-run, /api/admin/sync/execute-plan) на вызовы соответствующих Server Actions. Эти новые Server Actions должны быть созданы в файле actions.ts.
Цель: Устранить "архитектурную шизофрению" и привести компонент к единому, современному паттерну управления данными.
[Architecture/High Priority] Рефакторинг "God Component" с помощью кастомного хука:
План: Создать новый кастомный хук useClassificationManager. Вынести в этот хук всю логику и состояния из ClassificationClient: все useState, useTransition, useEffect, а также все функции-обработчики (handleCheckSync, handleCreateCategory и т.д.). Компонент должен будет только вызывать этот хук.
Цель: Радикально упростить компонент, отделив логику управления состоянием от представления (UI), что повысит читаемость, тестируемость и поддерживаемость.
[Refactoring/Medium Priority] Модуляризовать внутренние компоненты:
План: Вынести локально определенные компоненты (DragHandleIcon, ColorPicker, AddItemForm, ItemRow) в их собственные файлы в новой директории, например, /src/components/admin/classification/.
Цель: Улучшить структуру проекта, повысить читаемость и обеспечить переиспользуемость этих UI-элементов.
[Architecture/Medium Priority] Заменить иконки из @heroicons на локальные:
План: Создать в директории /src/components/icons собственные компоненты для ArrowPathIcon и BookOpenIcon. Заменить импорты из @heroicons/react на импорты этих локальных компонентов.
Цель: Обеспечить 100% консистентность в управлении иконками в соответствии с правилами проекта.
Статус: Отложено.
114. Улучшения серверной логики классификации (actions.ts):
Контекст: Файл является образцовым серверным модулем, демонстрирующим эталонное использование revalidatePath и prisma.$transaction. Его главные недостатки — неоптимальная стратегия для рекурсивного удаления и отсутствие строгой, централизованной валидации.
Задачи:
[Performance/High Priority] Оптимизировать рекурсивное удаление категорий:
План: Рефакторить функцию deleteCategory. Вместо множества рекурсивных вызовов внутри транзакции, необходимо сначала найти ID всех дочерних категорий на всех уровнях вложенности, а затем выполнить одно prisma.category.deleteMany({ where: { id: { in: [...allIdsToDelete] } } }).
Цель: Заменить неэффективный, "болтливый" подход к базе данных на единственную, высокопроизводительную операцию, что критически важно для производительности при удалении категорий с большим количеством подкатегорий.
[Refactoring/Code Quality] Внедрить Zod для валидации входных данных:
План: Создать Zod-схемы для данных категорий и тегов. В каждой Server Action (createCategory, updateTag и т.д.) использовать schema.safeParse() для валидации входных данных перед выполнением операции.
Цель: Устранить ручную, повторяющуюся логику валидации, сделать ее более надежной и следовать принципу DRY, создав единый источник правды для правил валидации.
Статус: Отложено.
115. Улучшения страницы управления фильтрами (filters/page.tsx):
Контекст: Компонент является высококачественной "кухней" с очень надежной логикой получения данных (prisma.upsert). Однако он страдает от двух системных проблем: неоптимальной стратегии рендеринга и использования "магической строки", связывающей его с главной страницей сайта.
Задачи:
[Performance/High Priority] Заменить force-dynamic на on-demand revalidation:
План: Удалить export const dynamic = 'force-dynamic';. Соответствующий Server Action, который будет сохранять изменения в фильтре, должен будет вызывать revalidatePath('/admin/filters') для обновления этой страницы и, что еще важнее, revalidatePath('/') для обновления главной страницы сайта.
Цель: Снизить нагрузку на БД и ускорить загрузку как админ-панели, так и публичного сайта.
[Architecture/High Priority] Централизовать "магическую строку" имени пресета:
План: Вынести строку 'main-store-filter' в глобальный файл с константами (например, /src/config/constants.ts). Этот файл (filters/page.tsx) и главная страница сайта ((site)/page.tsx) должны будут импортировать и использовать эту константу.
Цель: Устранить хрупкую неявную связь между админ-панелью и сайтом, следуя принципу DRY, и повысить надежность системы.
Статус: Отложено.
116. Модернизация клиента управления фильтрами (FilterManagerClient.tsx):
Контекст: Компонент обладает отличным UX и качественной реализацией сложного UI (Drag-and-Drop, "Dual List"). Однако его архитектура устарела из-за использования fetch к API-маршруту и alert() для обратной связи, что не соответствует стандартам проекта.
Задачи:
[Architecture/Highest Priority] Мигрировать логику сохранения на Server Action:
План: Заменить fetch-запрос в функции handleSave на вызов нового Server Action. Этот экшен будет принимать payload, выполнять транзакцию в Prisma для обновления FilterPreset и вызывать revalidatePath для админ-панели и главной страницы сайта (как определено в задаче №115).
Цель: Унифицировать архитектуру мутаций, устранить необходимость в кастомном API-маршруте и привести компонент в полное соответствие с современными паттернами проекта.
[UX/High Priority] Заменить alert() на централизованную систему уведомлений:
План: Интегрировать компонент с react-hot-toast. Заменить все вызовы alert() на toast.success() и toast.error(), используя глобальную систему уведомлений, которая уже есть в проекте.
Цель: Улучшить UX, предоставляя пользователю современную, неблокирующую обратную связь, и устранить архитектурный антипаттерн.
[Refactoring/Medium Priority] Централизовать локальные типы:
План: Переместить определения типов PresetWithItems и ManagedCategory из этого файла в центральный файл /src/lib/types.ts.
Цель: Обеспечить консистентность типов во всем приложении, следовать принципу DRY и сделать типы переиспользуемыми.
Статус: Отложено.
117. Архитектурное выравнивание SortableCategoryItem.tsx:
Контекст: Компонент является функционально образцовой реализацией "Dumb Component" для элементов с Drag-and-Drop. Однако он имеет два явных архитектурных нарушения: локальное определение иконки и импорт типа из родительского компонента, что создает неправильную зависимость.
Задачи:
[Architecture/High Priority] Централизовать компонент иконки:
План: Переместить локально определенный компонент GripVerticalIcon в его собственный файл в общую директорию /src/components/icons/. Компонент SortableCategoryItem должен будет импортировать его оттуда.
Цель: Обеспечить 100% консистентность в управлении иконками, следуя архитектурным правилам проекта.
[Architecture/Medium Priority] Централизовать определение типа ManagedCategory:
План: Переместить определение типа ManagedCategory из FilterManagerClient.tsx в центральный файл /src/lib/types.ts. Оба компонента (FilterManagerClient и SortableCategoryItem) должны будут импортировать этот тип из единого источника.
Цель: Устранить антипаттерн (зависимость дочернего файла от родительского), следовать принципу DRY для типов и повысить поддерживаемость.
Статус: Отложено.
118. Миграция API обновления фильтров на Server Action:
Контекст: Этот файл является эталоном с точки зрения качества кода, безопасности (Zod) и надежности (атомарная транзакция). Его единственный, но определяющий недостаток — архитектурный. Само его существование в виде кастомного API-маршрута противоречит нашей целевой архитектуре, основанной на Server Actions.
Задачи:
[Architecture/Highest Priority] Мигрировать логику в Server Action и удалить API-маршрут:
План:
Создать новый Server Action в соответствующем файле (например, src/app/admin/filters/actions.ts).
Полностью перенести всю логику из этого API-маршрута (Zod-схему, prisma.$transaction) в созданный Server Action.
После того как FilterManagerClient будет обновлен для вызова этого Server Action (согласно задаче №116), полностью удалить файл /api/admin/filters/update/route.ts.
Цель: Завершить архитектурную модернизацию модуля управления фильтрами, полностью устранив зависимость от устаревшего паттерна API Routes и консолидировав всю серверную логику в одном месте.
Статус: Отложено.
119. Полный рефакторинг и реализация "Почтового клиента" (mail/page.tsx):
Контекст: Компонент является функциональным прототипом, но с точки зрения архитектуры представляет собой монолитный "God Component", который нарушает принятый в проекте паттерн "Кухня-Зал". Он использует устаревший подход к получению данных, и большая часть его UI является нефункциональным макетом.
Задачи:
[Architecture/Highest Priority] Восстановить архитектурный паттерн "Кухня-Зал":
План: Провести полный рефакторинг.
Переименовать текущий файл в MailClient.tsx.
Создать новый серверный компонент page.tsx.
