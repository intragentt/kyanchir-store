
Главный Промпт-Архитектура «Kyanchir» (Версия 28.1)
Актуализация 18.10.2025: дизайн-система админки теперь централизует шрифты Manrope/PT Mono, палитры и каталог иконок, а для визуальной фиксации добавлен CLI-скрипт `npm run screenshot` (Playwright). См. `README_KYANCHIR.md` и `scripts/capture-screenshot.ts` для инструкций.
[+] src/app/api/admin/products/update-stock/route.ts
Анализ
Назначение: Этот API-маршрут является еще одним бэкендом для inline-редактирования в админ-панели (вероятнее всего, для компонента ProductSizeRow). Он обрабатывает POST-запросы для точечного обновления остатка (stock) для конкретной складской единицы (SKU).
Архитектура: Это динамический, защищенный API Route, который оркестрирует двухсистемную транзакцию.
Сильные стороны:
Безупречная реализация "Source of Truth" (Высший уровень): Этот файл в очередной раз демонстрирует идеальное следование нашей главной философии. Он сначала выполняет операцию во внешней системе (updateMoySkladVariantStock), и только после успешного завершения обновляет данные в нашей локальной базе данных (prisma.productSize.update).
Безопасность: Проверка сессии и роли администратора реализована корректно.
Недостатки и технический долг:
Критическая уязвимость целостности данных (Высший приоритет): Этот файл страдает от той же самой критической уязвимости, что и product-sizes/[id] и update-category. Логика обновления не является атомарной. Если updateMoySkladVariantStock выполнится успешно, а prisma.productSize.update завершится с ошибкой, мы получим рассинхронизацию остатков. Для e-commerce это одна из самых опасных ошибок, которая может привести к продаже отсутствующего товара.
Архитектурная неконсистентность (Высший приоритет): Вся эта важная логика находится в устаревшем API-маршруте, а не в Server Action.
Критическое нарушение принципа DRY (Высший приоритет): Блок проверки сессии и роли является точной копией кода из всех предыдущих административных эндпоинтов.
Отсутствие строгой валидации (Средний приоритет): Эндпоинт использует приведение типов (as RequestBody) и ручные if-проверки вместо безопасного парсинга с помощью zod, что является небезопасной практикой.
Итог
Этот файл — еще один яркий пример парадокса в нашем проекте: блестящая бизнес-логика, реализованная в технически хрупкой и опасной обертке. Он правильно понимает что делать, но делает это без защиты от сбоев, что создает серьезный риск для целостности самых важных данных — остатков на складе. Устранение этой уязвимости является задачей высочайшего приоритета.
Дата создания: 28 сентября 2025 г.
ЧАСТЬ 1: МОДЕЛЬ ВЗАИМОДЕЙСТВИЯ
1.1. Роли и Ответственность
Я — Архитектор: Задаю видение, проектирую логику и принимаю все итоговые решения.
Ты — Технический Партнёр: Ассистент-разработчик, который переводит мои решения в чистый, работающий код.
1.2. Фундаментальные Правила
Золотое Правило (Синхронизация): Никогда не гадай. Если сомневаешься в актуальности данных — всегда проси полный код нужного файла.
Железное Правило Кода (Доставка):
Один файл за раз: За одно сообщение ты присылаешь код только одного файла. Не больше, не меньше.
Всегда целиком: Код предоставляется полностью, без единого сокращения (...) или пропуска. Я всегда использую его для полной замены (Ctrl+A → Ctrl+V). Это правило действует, даже если изменение — один символ в файле из 5000 строк.
Исключение для "микро-правок": Если файл действительно огромен, а изменение тривиально и не требует размышлений (например, опечатка), ты можешь предложить инструкцию по замене. Если меня это не устроит, я просто пишу "код", и ты без возражений присылаешь полный файл.
1.3. Рабочие Процессы
Процесс Анализа: Мы движемся по дереву файлов. Я предоставляю файл, ты маркируешь его как [+] ИмяФайла и предоставляешь исчерпывающий анализ.
Процесс Разработки (4 Шага):
✅ Подтверждение →
📝 План (без кода) →
💻 Полный Код Файла (только после моего утверждения) →
📋 Инструкции (если требуются).
1.4. Стиль Общения
Тон: Партнёрский, прямой, на русском.
ЧАСТЬ 2: СТРУКТУРА ПРОЕКТА (СЛЕПОК ОТ 28.09.2025)
├── README.md ├── README_KYANCHIR.md ├── data │   └── products.csv ├── eslint.config.mjs ├── next-env.d.ts ├── next.config.mjs ├── package-lock.json ├── package.json ├── postcss.config.mjs ├── prettier.config.js ├── prisma │   ├── migrations │   │   ├── 20250927214901_init_modern_schema │   │   │   └── migration.sql │   │   └── migration_lock.toml │   ├── schema.prisma │   └── seed.ts ├── project-structure.txt ├── project_tree.txt ├── public │   ├── images │   │   └── how-to-measure.png │   ├── placeholder.png │   ├── uploads │   │   ├── 1754434951477-Фото_-_3.png │   │   ├── 1755177589971-Screenshot_2025-08-14_at_2.00.06_PM.png │   │   ├── 1755177596756-Screenshot_2025-08-13_at_3.44.59_AM.png │   │   ├── 1755177648337-placeholder.png │   │   ├── 1755177653286-Фото_-_3.png │   │   ├── 1755178046700-Фото_-_4.png │   │   ├── 1755178046710-Фото_-_2.png │   │   ├── 1755178046729-Фото_-_3.png │   │   ├── 1755178046736-placeholder.png │   │   ├── 1755178046799-Фото_-_1.png │   │   ├── 1755178283161-placeholder.png │   │   ├── 1755178283166-Фото_-_4.png │   │   ├── 1755178283169-Фото_-_1.png │   │   ├── 1755178283179-Фото_-_3.png │   │   ├── 1755178283201-Фото_-_2.png │   │   ├── 1755178546039-Фото_-_1.png │   │   ├── 1755178546040-Фото_-_2.png │   │   ├── 1755178546046-placeholder.png │   │   ├── 1755178546046-Фото_-_3.png │   │   ├── 1755203352119-Фото_-_2.png │   │   ├── 1755203352123-Фото_-_3.png │   │   ├── 1755203352131-Фото_-_1.png │   │   ├── 1755206370050-Фото_-_2.png │   │   ├── 1755206370059-Фото_-_4.png │   │   ├── 1755244985927-Фото_-_2.png │   │   ├── 1755244985928-Фото_-_4.png │   │   ├── 1755244985929-Фото_-_1.png │   │   ├── 1755244985934-Фото_-_3.png │   │   ├── 1755248622931-Фото_-_3.png │   │   ├── 1755248622936-Фото_-_4.png │   │   └── route.ts │   ├── Фото - 1.png │   ├── Фото - 2.png │   ├── Фото - 3.png │   └── Фото - 4.png ├── src │   ├── app │   │   ├── (site) │   │   │   ├── (auth) │   │   │   │   ├── forgot-password │   │   │   │   │   └── page.tsx │   │   │   │   ├── layout.tsx │   │   │   │   ├── login │   │   │   │   │   ├── page.tsx │   │   │   │   │   ├── verify-code │   │   │   │   │   │   └── page.tsx │   │   │   │   │   └── verify-request │   │   │   │   │       └── page.tsx │   │   │   │   ├── register │   │   │   │   │   └── page.tsx │   │   │   │   └── reset-password │   │   │   │       └── page.tsx │   │   │   ├── auth │   │   │   │   └── verify-email │   │   │   │       └── page.tsx │   │   │   ├── catalog │   │   │   │   └── page.tsx │   │   │   ├── layout.tsx │   │   │   ├── loading.tsx │   │   │   ├── page.tsx │   │   │   ├── product │   │   │   │   └── [id] │   │   │   │       └── page.tsx │   │   │   ├── profile │   │   │   │   ├── ProfileClient.tsx │   │   │   │   ├── SignOutButton.tsx │   │   │   │   ├── actions.ts │   │   │   │   └── page.tsx │   │   │   ├── support │   │   │   │   └── page.tsx │   │   │   └── verify-email │   │   │       └── page.tsx │   │   ├── admin │   │   │   ├── categories │   │   │   │   ├── ClassificationClient.tsx │   │   │   │   ├── actions.ts │   │   │   │   └── page.tsx │   │   │   ├── dashboard │   │   │   │   └── page.tsx │   │   │   ├── filters │   │   │   │   ├── FilterManagerClient.tsx │   │   │   │   ├── SortableCategoryItem.tsx │   │   │   │   ├── page.tsx │   │   │   │   └── update │   │   │   ├── layout.tsx │   │   │   ├── mail │   │   │   │   ├── MailClient.tsx │   │   │   │   └── page.tsx │   │   │   ├── mappings │   │   │   │   ├── actions.ts │   │   │   │   └── page.tsx │   │   │   ├── page.tsx │   │   │   └── products │   │   │       ├── [id] │   │   │       │   └── edit │   │   │       │       └── page.tsx │   │   │       └── new │   │   │           └── page.tsx │   │   ├── api │   │   │   ├── admin │   │   │   │   ├── filters │   │   │   │   │   └── update │   │   │   │   │       └── route.ts │   │   │   │   ├── product-sizes │   │   │   │   │   ├── [id] │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── route.ts │   │   │   │   ├── products │   │   │   │   │   ├── create │   │   │   │   │   │   └── route.ts │   │   │   │   │   ├── update-category │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── update-stock │   │   │   │   │       └── route.ts │   │   │   │   ├── settings │   │   │   │   │   ├── moysklad-key │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── test-moysklad-key │   │   │   │   │       └── route.ts │   │   │   │   ├── sync │   │   │   │   │   ├── categories │   │   │   │   │   │   └── route.ts │   │   │   │   │   ├── dry-run │   │   │   │   │   │   └── route.ts │   │   │   │   │   ├── execute-plan │   │   │   │   │   │   └── route.ts │   │   │   │   │   ├── products │   │   │   │   │   │   ├── new │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── reset-products │   │   │   │   │       └── route.ts │   │   │   │   ├── tickets │   │   │   │   │   ├── [id] │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── route.ts │   │   │   │   ├── utils │   │   │   │   │   ├── backfill-skus │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── execute-sku-plan │   │   │   │   │       └── route.ts │   │   │   │   └── variants │   │   │   │       └── route.ts │   │   │   ├── auth │   │   │   │   ├── [...nextauth] │   │   │   │   │   └── route.ts │   │   │   │   ├── check-login-token │   │   │   │   │   └── route.ts │   │   │   │   ├── check-user │   │   │   │   │   └── route.ts │   │   │   │   ├── create-login-token │   │   │   │   │   └── route.ts │   │   │   │   ├── login │   │   │   │   ├── logout │   │   │   │   │   └── route.ts │   │   │   │   ├── password-reset │   │   │   │   │   ├── confirm │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── request │   │   │   │   │       └── route.ts │   │   │   │   ├── register │   │   │   │   │   └── route.ts │   │   │   │   ├── send-login-code │   │   │   │   │   └── route.ts │   │   │   │   ├── send-verification-code │   │   │   │   │   └── route.ts │   │   │   │   ├── send-verification-link │   │   │   │   │   └── route.ts │   │   │   │   ├── telegram │   │   │   │   │   ├── check │   │   │   │   │   │   └── route.ts │   │   │   │   │   ├── finalize │   │   │   │   │   │   └── route.ts │   │   │   │   │   └── start │   │   │   │   │       └── route.ts │   │   │   │   ├── validate-credentials │   │   │   │   │   └── route.ts │   │   │   │   ├── verify │   │   │   │   ├── verify-code │   │   │   │   │   └── route.ts │   │   │   │   ├── verify-email │   │   │   │   │   └── route.ts │   │   │   │   ├── verify-login-code │   │   │   │   │   └── route.ts │   │   │   │   └── verify-token │   │   │   │       └── route.ts │   │   │   ├── bot │   │   │   │   ├── create-login-link │   │   │   │   │   └── route.ts │   │   │   │   └── route.ts │   │   │   ├── mail-webhook │   │   │   │   └── route.ts │   │   │   ├── moysklad-webhook │   │   │   │   └── route.ts │   │   │   ├── products │   │   │   │   ├── [id] │   │   │   │   │   └── route.ts │   │   │   │   ├── bulk-update-status │   │   │   │   │   └── route.ts │   │   │   │   └── route.ts │   │   │   ├── support-form │   │   │   │   └── route.ts │   │   │   ├── telegram-webhook │   │   │   │   └── route.ts │   │   │   ├── upload │   │   │   │   └── route.ts │   │   │   ├── user │   │   │   │   └── profile │   │   │   │       └── route.ts │   │   │   ├── variants │   │   │   │   ├── [id] │   │   │   │   │   └── route.ts │   │   │   │   ├── batch-update │   │   │   │   │   └── route.ts │   │   │   │   └── route.ts │   │   │   └── webhooks │   │   │       └── telegram │   │   │           └── support │   │   │               └── route.ts │   │   ├── favicon.ico │   │   ├── favicon.svg │   │   ├── fonts.ts │   │   ├── globals.css │   │   └── layout.tsx │   ├── components │   │   ├── AppCore.tsx │   │   ├── AvatarPlaceholder.tsx │   │   ├── CatalogContent.tsx │   │   ├── CategoryFilter.tsx │   │   ├── ClientInteractivity.tsx │   │   ├── ConditionalHeader.tsx │   │   ├── CookieConsentBanner.tsx │   │   ├── DynamicHeroSection.tsx │   │   ├── FloatingLogoButton.tsx │   │   ├── FloatingMenuOverlay │   │   │   ├── AuthenticatedView.tsx │   │   │   ├── CartSummary.tsx │   │   │   ├── DeliveryStatus.tsx │   │   │   ├── GuestView.tsx │   │   │   ├── InfoLinks.tsx │   │   │   ├── MenuButton.tsx │   │   │   ├── MenuFooter.tsx │   │   │   ├── MenuHeader.tsx │   │   │   ├── ShopNavigation.tsx │   │   │   ├── StatusStep.tsx │   │   │   └── index.tsx │   │   ├── Footer.tsx │   │   ├── Header.tsx │   │   ├── HeroSection.tsx │   │   ├── HomePageClient.tsx │   │   ├── HybridHeader.tsx │   │   ├── ImagePlaceholder.tsx │   │   ├── MiniBannerSlider.tsx │   │   ├── NetworkStatusManager.tsx │   │   ├── NotificationManager.tsx │   │   ├── Preloader.tsx │   │   ├── ProductCard.tsx │   │   ├── ProductDetails.tsx │   │   ├── SaleBadge.tsx │   │   ├── SearchOverlay.tsx │   │   ├── SmartStickyCategoryFilter.tsx │   │   ├── admin │   │   │   ├── AddSizeForm.tsx │   │   │   ├── AddVariantForm.tsx │   │   │   ├── AdminHeader.tsx │   │   │   ├── ApiKeyModal.tsx │   │   │   ├── ConflictResolutionModal.tsx │   │   │   ├── CreateProductForm.tsx │   │   │   ├── DashboardControls.tsx │   │   │   ├── DryRunModal.tsx │   │   │   ├── EditProductDetails.tsx │   │   │   ├── EditProductForm.tsx │   │   │   ├── MappingsTable.tsx │   │   │   ├── ProductTable.tsx │   │   │   ├── VariantManager.tsx │   │   │   ├── edit-product-form │   │   │   │   ├── AboutProductManager.tsx │   │   │   │   ├── AttributeManager.tsx │   │   │   │   ├── CategoryManager.tsx │   │   │   │   ├── DescriptionManager.tsx │   │   │   │   ├── DetailManager.tsx │   │   │   │   ├── ImageManager.tsx │   │   │   │   ├── PriceManager.tsx │   │   │   │   ├── SizeManager.tsx │   │   │   │   ├── SkuManager.tsx │   │   │   │   └── VariantManager.tsx │   │   │   ├── layout.tsx │   │   │   └── product-table │   │   │       ├── EditableCountdownTimer.tsx │   │   │       ├── ExpanderCell.tsx │   │   │       ├── ProductDetailsPanel.tsx │   │   │       ├── ProductSizeRow.tsx │   │   │       ├── ProductTableRow.tsx │   │   │       └── VariantRow.tsx │   │   ├── auth │   │   │   ├── CodeInput.tsx │   │   │   ├── ForgotPasswordForm.tsx │   │   │   ├── ResetPasswordForm.tsx │   │   │   └── VerificationModal.tsx │   │   ├── header │   │   │   ├── DesktopNav.tsx │   │   │   └── MobileNav.tsx │   │   ├── hooks │   │   │   ├── useElementRect.ts │   │   │   ├── useFilterRect.ts │   │   │   ├── useHybridHeader.ts │   │   │   ├── useScrollInfo.ts │   │   │   ├── useSmartSticky.ts │   │   │   └── useStickyCategoryFilter.ts │   │   ├── icons │   │   │   ├── AdminIcon.tsx │   │   │   ├── ArrowRightIcon.tsx │   │   │   ├── BurgerIcon.tsx │   │   │   ├── CartIcon.tsx │   │   │   ├── CheckIcon.tsx │   │   │   ├── ChevronDownIcon.tsx │   │   │   ├── ChevronIcon.tsx │   │   │   ├── ChevronRightIcon.tsx │   │   │   ├── ClearIcon.tsx │   │   │   ├── ClockIcon.tsx │   │   │   ├── CloseIcon.tsx │   │   │   ├── CopyIcon.tsx │   │   │   ├── DiscountBadgeIcon.tsx │   │   │   ├── EmailIcon.tsx │   │   │   ├── EyeIcon.tsx │   │   │   ├── EyeOffIcon.tsx │   │   │   ├── HeartIcon.tsx │   │   │   ├── Logo.tsx │   │   │   ├── LogoutIcon.tsx │   │   │   ├── PencilIcon.tsx │   │   │   ├── QuestionMarkIcon.tsx │   │   │   ├── ReceiptIcon.tsx │   │   │   ├── SearchIcon.tsx │   │   │   ├── SettingsIcon.tsx │   │   │   ├── ShareIcon.tsx │   │   │   ├── ShortLogo.tsx │   │   │   ├── SortIcon.tsx │   │   │   ├── SpinnerIcon.tsx │   │   │   ├── SunIcon.tsx │   │   │   ├── TelegramOfficialIcon.tsx │   │   │   ├── ThumbsUpIcon.tsx │   │   │   ├── TrashIcon.tsx │   │   │   ├── TruckIcon.tsx │   │   │   ├── UserIcon.tsx │   │   │   └── XMarkIcon.tsx │   │   ├── illustrations │   │   │   └── ArrowStep1.tsx │   │   ├── layout │   │   │   ├── CatalogHeaderController.tsx │   │   │   ├── ProductPageHeader.tsx │   │   │   ├── StickyCategoryFilter.tsx │   │   │   ├── StickyHeader.tsx │   │   │   └── StickyProductPageHeader.tsx │   │   ├── modals │   │   │   ├── CodeInput.tsx │   │   │   └── VerificationModal.tsx │   │   ├── product-details │   │   │   ├── AddToCartButton.tsx │   │   │   ├── DesktopActionButtons.tsx │   │   │   ├── DesktopProductGallery.tsx │   │   │   ├── DesktopSizeAndCartButton.tsx │   │   │   ├── LowStockBadge.tsx │   │   │   ├── MobileProductGallery.tsx │   │   │   ├── ProductActions.tsx │   │   │   ├── ProductAttributes.tsx │   │   │   ├── ProductGallery.tsx │   │   │   ├── ProductHeader.tsx │   │   │   ├── SizeChart.tsx │   │   │   ├── SizeGuideContent.tsx │   │   │   └── SizeSelector.tsx │   │   ├── profile │   │   │   ├── EditPasswordForm.tsx │   │   │   ├── EditProfileForm.tsx │   │   │   ├── ProfileHeader.tsx │   │   │   └── ProfileInfoBlock.tsx │   │   ├── providers │   │   │   └── AuthProvider.tsx │   │   └── ui │   │       ├── BottomSheet.tsx │   │       └── Button.tsx │   ├── config │   │   └── navigation.ts │   ├── context │   │   └── FooterContext.tsx │   ├── hooks │   │   ├── useMediaQuery.ts │   │   └── useSmartSticky.ts │   ├── lib │   │   ├── auth.ts │   │   ├── csvParser.ts │   │   ├── encryption.ts │   │   ├── mail.ts │   │   ├── moysklad-api.ts │   │   ├── prisma.ts │   │   ├── session.ts │   │   ├── sku-generator.ts │   │   ├── telegram.ts │   │   ├── types.ts │   │   └── utils.ts │   ├── middleware.ts │   ├── store │   │   └── useAppStore.ts │   ├── types │   │   └── next-auth.d.ts │   └── utils │       ├── formatPrice.ts │       └── formatTimeLeft.ts ├── tailwind.config.ts ├── telegram.d.ts ├── tsconfig.json ├── tsconfig.seed.json └── vercel.json  128 directories, 309 files
ЧАСТЬ 3: АНАЛИЗ ФАЙЛОВ ПРОЕКТА
[+] package.json
Тип: Технический манифест проекта.
Назначение: Определяет зависимости, скрипты и метаданные.
1. Рабочие процессы (scripts):
build: prisma generate && next build. Ключевой процесс: Гарантирует свежесть Prisma-клиента перед сборкой.
db:seed: tsx prisma/seed.ts. Прямой запуск TS-скриптов для сидинга БД.
postinstall: prisma generate. Автоматизация: Обеспечивает актуальность Prisma-клиента после установки зависимостей (npm install).
2. Зависимости по функциональным ролям (dependencies):
Core Framework: next@^14.2.3, react@^18.3.1. (Основа: App Router).
Database & ORM: @prisma/client, @auth/prisma-adapter. (Слой доступа к данным, PostgreSQL).
Authentication: next-auth@^4.24.7, bcrypt, jose. (Управление сессиями, хэширование паролей, JWT).
State Management: zustand. (Глобальное состояние UI).
UI & Interactivity:
tailwindcss, @headlessui/react, lucide-react. (Стили, компоненты, иконки).
@dnd-kit/core, @dnd-kit/sortable. (Маркер: Реализован Drag-and-Drop).
swiper. (Маркер: Реализованы слайдеры/карусели).
Backend & Integrations:
telegraf. (Маркер: Интеграция с Telegram Bot API).
nodemailer, @sendgrid/mail. (Система отправки email).
formidable. (Маркер: Реализована загрузка файлов через multipart/form-data).
zod. (Маркер: Валидация схем на стороне сервера).
3. Инструменты разработки (devDependencies):
Code Quality: eslint, prettier, prettier-plugin-tailwindcss. (Линтинг и форматирование).
Security: server-only. (Маркер: Принудительное ограничение выполнения модулей на сервере для предотвращения утечек).
ORM Tooling: prisma (CLI).
TS Execution: tsx.
4. Ключевые архитектурные выводы:
Безопасность: Активно используется server-only для изоляции серверного кода и bcrypt для паролей.
Надежность: Процессы сборки (build) и установки (postinstall) принудительно синхронизируют Prisma-клиент, минимизируя ошибки рассинхронизации.
Функционал: Проект поддерживает загрузку файлов (formidable) и сложные UI-взаимодействия в админ-панели (@dnd-kit).
Стек: Современный, full-stack TypeScript проект с четким разделением технологий по задачам.
[+] next.config.mjs
Тип: Файл конфигурации фреймворка Next.js.
Назначение: Определяет глобальные правила сборки, маршрутизации и безопасности для всего приложения.
1. Конфигурация сборки (eslint):
Параметр: ignoreDuringBuilds: true.
Техническое следствие: Команда next build будет успешно завершена, даже если в коде присутствуют ошибки ESLint.
Вывод: Проверка качества кода (линтинг) вынесена в отдельный шаг (npm run lint) и не является блокирующей для сборки и развертывания проекта.
2. Конфигурация безопасности (headers):
Параметр: Для всех маршрутов (source: '/(.*)') добавляется HTTP-заголовок X-Frame-Options: SAMEORIGIN.
Техническое следствие: Запрещает встраивание сайта в <iframe> на сторонних доменах.
Вывод: Реализована базовая защита от атак типа "clickjacking".
3. Конфигурация маршрутизации (redirects):
Правила: Настроен набор постоянных (308) редиректов. Множество URL-алиасов (/help, /pomagite, /помощь и т.д.) перенаправляются на единый канонический маршрут /support.
Вывод: Улучшает SEO и пользовательский опыт, централизуя трафик на одной странице.
Архитектурный маркер: В коде присутствует закомментированный блок, явно указывающий, что логика редиректа для админ-панели была сознательно удалена из этого файла и перенесена в middleware.ts для более гибкой обработки. Это подтверждает архитектурное решение по управлению субдоменом.
4. Конфигурация оптимизации изображений (images):
Параметр: Блок images.remotePatterns присутствует в файле, но полностью закомментирован.
Техническое следствие: Приложение на данный момент не использует встроенную в Next.js систему оптимизации для изображений, размещенных на внешних серверах или CDN.
Вывод: Вся работа с изображениями, вероятно, ограничивается локальными файлами из папки /public, либо оптимизация для внешних источников еще не требовалась.
[+] tailwind.config.ts
Тип: Конфигурация Design System.
Назначение: Определяет всю визуальную систему проекта: цвета, шрифты, отступы, адаптивность и кастомные утилиты, используемые Tailwind CSS.
1. Область сканирования (content):
Конфигурация: Стандартная для Next.js App Router. Tailwind отслеживает классы в директориях /src/app, /src/components и /src/pages.
2. Кастомизация темы (theme):
Breakpoints (screens):
Используются стандартные брейкпоинты (sm, md, lg, xl, 2xl).
Маркер: Добавлен кастомный брейкпоинт kyanchir-lg: '1025px'. Это указывает на необходимость тонкой настройки макета в точке перехода от планшетных к десктопным разрешениям, вероятно, для избежания "прыжка" или наложения элементов.
Цветовая палитра (colors):
Архитектура: Цвета организованы семантически по группам: brand (фирменные), accent (акцентные), feedback (для состояний), text (текстовые) и background (фоновые). Это указывает на системный подход к дизайну.
Шрифты (fontFamily):
Архитектура: Шрифты (heading, body, mono) подключаются через CSS переменные (var(...)). Это каноничный способ интеграции кастомных шрифтов, загружаемых через next/font (вероятно, в src/app/fonts.ts или layout.tsx).
Типографика (fontSize, typographyStyles):
Маркер (продвинутая техника): Используется функция CSS clamp() для создания "резиновой" типографики (clamp-banner-main). Это обеспечивает плавное масштабирование текста между брейкпоинтами.
Маркер (кастомная система): В конфиг добавлена нестандартная секция typographyStyles. Она содержит определения для классов типографики (h1, h2, body-base) с указанием стилей для разных брейкпоинтов.
3. Плагины (plugins):
@tailwindcss/forms: Стандартный плагин для базовой стилизации HTML-форм.
Кастомный плагин типографики:
Назначение: Написан кастомный плагин, который программно считывает объект typographyStyles из темы.
Функционал: Он автоматически генерирует адаптивные utility-классы (.text-h1, .text-h2, .text-body-base и т.д.).
Архитектурное следствие: Это мощное решение, следующее принципу DRY (Don't Repeat Yourself). Вместо того чтобы в компонентах писать длинные строки классов (className="text-3xl md:text-4xl lg:text-5xl"), разработчик может использовать один семантический класс className="text-h1". Вся логика адаптивности инкапсулирована здесь, в конфиге.
4. Ключевые архитектурные выводы:
Это не просто Tailwind, это Design System: Проект не использует Tailwind "из коробки", а выстраивает на его основе собственную, строго определенную дизайн-систему с семантическими цветами и централизованной типографикой.
Продвинутые Frontend-техники: Использование clamp() для "резиновой" типографики и написание кастомного плагина для генерации утилит свидетельствует о высоком уровне проработки фронтенда.
Централизация и DRY: Кастомный плагин является ключевым архитектурным решением, которое делает код компонентов чище, а управление типографикой — централизованным и более простым для поддержки.
Актуальность: В коде явно отмечено удаление плагина @tailwindcss/line-clamp, так как его функционал стал встроенным в ядро Tailwind. Это говорит о том, что за конфигурацией следят и поддерживают ее в актуальном состоянии.
[+] tsconfig.json
Тип: Конфигурация компилятора TypeScript.
Назначение: Определяет, как TypeScript будет проверять типы, разрешать модули и понимать синтаксис во всем проекте.
1. Основные параметры (compilerOptions):
strict: true: Ключевой маркер. Проект использует самый строгий режим проверки типов TypeScript. Это указывает на высокий стандарт качества кода и стремление к максимальной типобезопасности.
moduleResolution: "bundler": Используется современная стратегия разрешения модулей, являющаяся стандартом для проектов, использующих бандлеры (как Next.js).
paths: { "@/*": ["./src/*"] }: Ключевой маркер. Настроены псевдонимы путей (path aliases). Это архитектурное решение, которое позволяет использовать абсолютные импорты (@/components/...) вместо сложных относительных (../../../), что радикально улучшает читаемость и поддерживаемость кода.
noEmit: true: TypeScript используется только для проверки типов. Процесс компиляции (транспиляции) из TS в JS полностью делегирован встроенному в Next.js компилятору (SWC).
2. Область проверки (include / exclude):
Конфигурация: В область проверки включены все файлы .ts и .tsx, а также ключевые файлы конфигурации (.mjs).
Маркер (Ошибка конфигурации): Обнаружена некорректная запись в массиве include: "src/app/api/auth/verify-code/route.ts.дtkk". Это явная опечатка в расширении файла. Она не вызывает сбоя, так как такого файла не существует, но является техническим артефактом, который необходимо исправить.
3. Ключевые архитектурные выводы:
Проект настроен с упором на строгую типизацию, что является фундаментом для написания надежного и предсказуемого кода.
Использование псевдонимов путей (@/*) является лучшей практикой для крупных проектов на Next.js.
Конфигурация в целом соответствует каноническим настройкам для современного Next.js-приложения, за исключением небольшой опечатки в include.
[+] prettier.config.js
Тип: Конфигурация форматера кода.
Назначение: Устанавливает единый и строгий набор правил для автоматического форматирования всего кода в проекте, устраняя споры о стиле.
1. Конфигурация:
Плагины (plugins):
prettier-plugin-tailwindcss: Ключевой плагин. Автоматически сортирует классы Tailwind CSS в каноническом порядке. Это не просто стилистическое, а архитектурное решение для повышения читаемости и поддерживаемости компонентов.
Стилистические правила:
semi: true: Точки с запятой в конце строк обязательны.
singleQuote: true: Для строк используются одинарные кавычки.
trailingComma: 'all': Замыкающие запятые добавляются везде, где это возможно (массивы, объекты, параметры функций).
2. Ключевые архитектурные выводы:
Единый стандарт кода: Наличие этого файла гарантирует, что весь код в проекте выглядит одинаково, независимо от того, кто его написал.
Автоматизация качества: Форматирование не является ручной задачей, а выполняется инструментом автоматически.
Оптимизация для Tailwind: Проект специально настроен для максимально эффективной работы с Tailwind CSS.
Чистота истории Git: Правило trailingComma: 'all' является лучшей практикой для систем контроля версий. Оно упрощает отслеживание изменений (diffs), так как добавление нового элемента в список не приводит к изменению предыдущей строки.
[+] eslint.config.mjs
Тип: Конфигурация статического анализатора кода (линтера).
Назначение: Определяет набор правил для поиска и исправления проблемного кода, обеспечения единого стиля и предотвращения потенциальных ошибок.
1. Архитектура конфигурации:
Маркер (Современный формат): Используется новый "Flat Config" формат ESLint (файл .mjs, экспорт массива). Это указывает на то, что инструментарий проекта настроен в соответствии с последними стандартами.
Маркер (Совместимость): Применяется FlatCompat для использования "старых" конфигураций в новом формате. Это каноничный и правильный способ миграции.
2. Применяемые правила:
Конфигурация: ...compat.extends("next/core-web-vitals", "next/typescript").
Техническое следствие: Проект не определяет десятки правил вручную, а использует официальные, предустановленные наборы правил от команды Next.js.
next/core-web-vitals: Этот набор автоматически проверяет код на соответствие лучшим практикам производительности, таким как правильное использование <Image>, <Link>, асинхронных компонентов и загрузки шрифтов.
next/typescript: Обеспечивает интеграцию ESLint с правилами TypeScript.
3. Ключевые архитектурные выводы:
Фокус на стандартах фреймворка: Вместо создания собственной сложной конфигурации, проект доверяет экспертизе команды Vercel/Next.js. Это гарантирует, что код будет соответствовать лучшим практикам производительности и доступности.
Современный инструментарий: Использование Flat Config показывает, что проект поддерживает свой инструментарий в актуальном состоянии.
Минимализм и эффективность: Конфигурация максимально проста и декларативна, но при этом обеспечивает очень мощный уровень статического анализа благодаря качеству расширяемых наборов правил.
[+] vercel.json
Тип: Конфигурация платформы Vercel.
Назначение: Определяет специфичные для Vercel настройки, в данном случае — для выполнения запланированных задач (Cron Jobs).
1. Конфигурация (crons):
Задача: В файле определена одна запланированная задача.
Действие (path): Вызывает (делает GET-запрос) на внутренний API-маршрут /api/admin/sync/products.
Расписание (schedule): "0 0 * * *". Это стандартный cron-синтаксис, означающий "Выполнять каждый день в 00:00 UTC" (в полночь по Гринвичу).
Безопасность (query): URL содержит параметр ?cron_secret=.... Это маркер безопасности. API-маршрут на сервере должен проверять наличие и соответствие этого секрета, чтобы убедиться, что запрос инициирован именно Vercel, а не сторонним лицом.
2. Ключевые архитектурные выводы:
Серверлесс-автоматизация: Проект использует нативную функцию Vercel Cron Jobs для выполнения фоновых, периодических задач. Это указывает на архитектуру, ориентированную на серверлесс.
Критический бизнес-процесс: Существует автоматизированный процесс ежедневной синхронизации продуктов, что, вероятно, является ключевой частью бизнес-логики (например, обновление остатков и цен из "МойСклад").
Риск безопасности: Секрет для cron-задачи (cron_secret) захардкожен прямо в конфигурационном файле. Это является уязвимостью, так как любой, кто имеет доступ к репозиторию, видит этот секрет.
[+] tsconfig.seed.json
Тип: Специализированная конфигурация TypeScript.
Назначение: Определяет правила компиляции только для скрипта наполнения базы данных (prisma/seed.ts), который выполняется в среде Node.js.
1. Ключевая конфигурация:
"module": "CommonJS": Это главное отличие от основного tsconfig.json. Данная настройка необходима для корректного выполнения TS-скрипта напрямую в среде Node.js с помощью утилиты tsx (которая используется в нашем npm run db:seed).
"moduleResolution": "node": Используется классическая стратегия разрешения модулей Node.js.
2. Ключевые архитектурные выводы:
Изоляция конфигураций: Проект грамотно разделяет конфигурацию TypeScript для основного приложения Next.js (которое использует esnext модули) и для отдельных скриптов, выполняемых в Node.js (которые требуют CommonJS).
Надежность скриптов: Наличие этого файла гарантирует, что seed-скрипт будет выполняться в предсказуемой и правильной среде, независимо от настроек основного приложения. Это предотвращает потенциальные конфликты и ошибки при запуске служебных скриптов.
[+] telegram.d.ts
Тип: Файл декларации типов TypeScript (.d.ts).
Назначение: Описывает для TypeScript структуру глобального объекта window.Telegram.WebApp, который не существует в обычном браузере, а внедряется в веб-страницу только тогда, когда она открыта внутри клиента Telegram (как Mini App / Web App).
1. Описываемый функционал:
Декларация: Файл расширяет глобальный Window и описывает объект Telegram.WebApp.
Ключевые методы:
ready(), expand(), close(): Базовые методы для управления жизненным циклом Mini App (сообщить о готовности, развернуть на весь экран, закрыть).
setHeaderColor(): Позволяет веб-приложению динамически изменять цвет хедера в нативном интерфейсе Telegram, создавая бесшовный пользовательский опыт.
BackButton: Описывает объект для управления нативной кнопкой "Назад" в клиенте Telegram. Позволяет ее показывать, скрывать и назначать на нее кастомные обработчики.
2. Ключевые архитектурные выводы:
Это Telegram Mini App: Наличие этого файла является неопровержимым доказательством того, что проект спроектирован не просто как самостоятельный веб-сайт, а как полноценное приложение, встраиваемое в Telegram (Mini App). Это ключевая функциональная особенность.
Глубокая интеграция с клиентом: Проект не просто открывается по ссылке, он активно взаимодействует с нативным UI мессенджера (управляет кнопкой "Назад", цветом хедера). Это позволяет создавать гораздо более гладкий и интегрированный пользовательский опыт.
Фронтенд для бота: Этот файл описывает фронтенд-часть взаимодействия с Telegram, которая является дополнением к бэкенд-логике бота, реализованной с помощью библиотеки Telegraf (из package.json).
[+] postcss.config.mjs
Тип: Конфигурация CSS-процессора.
Назначение: Определяет, какие плагины будут обрабатывать CSS-код после его написания, но до того, как он будет отправлен в браузер.
1. Конфигурация (plugins):
tailwindcss: {}: Основной движок. Этот плагин является ядром Tailwind CSS. Он сканирует все файлы проекта, находит в них utility-классы и генерирует на их основе финальный CSS-файл.
autoprefixer: {}: Гарант совместимости. Этот плагин автоматически добавляет вендорные префиксы (например, -webkit-, -moz-, -ms-) к CSS-свойствам. Это обеспечивает корректное отображение стилей в старых версиях различных браузеров.
2. Ключевые архитектурные выводы:
Стандартная и корректная настройка: Данная конфигурация является стандартной и рекомендованной для любого проекта, использующего Tailwind CSS.
Автоматизация кросс-браузерности: Проект не требует ручного написания префиксов, что упрощает разработку и гарантирует широкую совместимость стилей.
[+] .gitignore
Тип: Файл правил для системы контроля версий Git.
Назначение: Определяет список файлов и папок, которые должны быть проигнорированы Git и не должны попадать в репозиторий.
1. Ключевые правила и их значение:
Зависимости (/node_modules): Стандартная практика. Зависимости устанавливаются через package.json и не хранятся в репозитории.
Артефакты сборки (/.next/, /out/, /build): Результаты сборки проекта генерируются на основе исходного кода и не версионируются.
Секреты и чувствительные данные:
.env*: Критически важный маркер безопасности. Все файлы с переменными окружения (включая .env.local, .env.production) игнорируются. Это правильная и безопасная архитектура для управления секретами.
.pem: Игнорируются файлы приватных ключей. Это дополнительный слой безопасности.
Служебные файлы: Игнорируются системные файлы (.DS_Store), логи (npm-debug.log*) и артефакты TypeScript (*.tsbuildinfo, next-env.d.ts).
Prisma Client:
/src/generated/prisma: Нестандартный архитектурный маркер. По умолчанию Prisma Client генерируется в node_modules. Наличие этой строки указывает на то, что в проекте (возможно, в прошлом) была настроена кастомная директория для генерации клиента Prisma. Это решение, которое обычно принимают для явного контроля над генерируемым кодом или для решения специфичных проблем со сборкой.
2. Ключевые архитектурные выводы:
Следование лучшим практикам: Файл .gitignore настроен в соответствии со всеми современными стандартами для Next.js-проектов.
Безопасность — приоритет: Проект жестко разделяет код и секреты, что является основой безопасной разработки.
Потенциальный артефакт конфигурации: Правило /src/generated/prisma требует дополнительного исследования. Необходимо проверить файл prisma/schema.prisma, чтобы понять, является ли это правило актуальным или устаревшим наследием.
[+] .env.local
Тип: Файл переменных окружения.
Назначение: Централизованное хранилище всех секретов, ключей API и конфигураций, специфичных для локального окружения. Этот файл находится в .gitignore и не должен попадать в репозиторий.
1. Инфраструктура и Сервисы:
База данных (DATABASE_URL):
Маркер: Проект использует управляемую серверлесс-базу данных PostgreSQL от Neon (aws.neon.tech).
Отправка Email (EMAIL_*):
Маркер: В качестве провайдера для отправки транзакционных email используется SendGrid (хост smtp.sendgrid.net и ключ SG.*).
Аутентификация (AUTH_*):
Маркер: Стандартная конфигурация для next-auth@v4, включающая AUTH_SECRET для подписи JWT и NEXTAUTH_URL для корректной работы редиректов.
Складской учёт (MOYSKLAD_API_TOKEN):
Маркер: Прямое подтверждение интеграции с сервисом "МойСклад" через API-токен.
Запланированные задачи (CRON_SECRET):
Маркер: Содержит секретный ключ для верификации запросов от Vercel Cron Jobs.
2. Ключевые архитектурные решения:
Система из двух Telegram-ботов:
Клиентский бот (TELEGRAM_BOT_TOKEN): Используется для взаимодействия с клиентами. Наличие NEXT_PUBLIC_TELEGRAM_BOT_USERNAME указывает на то, что его имя используется на фронтенде, что подтверждает архитектуру Telegram Mini App.
Административный бот (TELEGRAM_SUPPORT_BOT_TOKEN): Отдельный бот для сотрудников. Наличие TELEGRAM_ADMIN_IDS является маркером системы авторизации, где доступ к боту есть только у определённого списка администраторов.
Система шифрования PII:
Маркер: Наличие ENCRYPTION_KEY и ENCRYPTION_SALT является прямым доказательством реализации кастомной системы шифрования персональных данных (имени, email и т.д.) перед сохранением в базу данных. Эти ключи используются модулем /lib/encryption.ts.
3. Выводы:
Файл подтверждает использование современного облачного стека (Neon, SendGrid).
Раскрывает сложную архитектуру с двумя отдельными Telegram-ботами для разных задач (клиентской и административной).
Подтверждает наличие продвинутой системы безопасности, включающей шифрование персональных данных на уровне приложения.
[+] data/products.csv
Тип: Файл с данными (Legacy).
Назначение: Использовался для первоначального наполнения базы данных на ранних этапах проекта через скрипт prisma/seed.ts (с помощью papaparse).
Статус: Устаревший артефакт. Подтверждено Архитектором. Файл больше не является источником правды и не отражает актуальные данные о товарах. Единственный источник правды — "МойСклад".
[+] prisma/schema.prisma
Тип: Схема данных (Data Definition Language).
Назначение: Является "конституцией" и единственным источником правды для структуры базы данных PostgreSQL. Определяет все таблицы (модели), поля и связи между ними.
1. Логические Домены:
Схема грамотно и четко разделена на 5 логических доменов:
Домен "Продукты":
Архитектура: Реализована классическая и надежная структура Product -> ProductVariant -> ProductSize. Это позволяет гибко управлять товарами, их цветами и конкретными размерами на складе.
Маркеры: Поля moyskladId и moySkladHref на разных уровнях подтверждают глубокую интеграцию с "МойСклад". Модель Category поддерживает вложенность (самореференция parent/children).
Домен "Заказы":
Архитектура: Стандартная структура Order -> OrderItem.
Маркер целостности данных: Связь OrderItem с ProductSize использует onDelete: Restrict. Это критически важное правило, которое запрещает удаление товарной позиции, если она является частью уже существующего заказа. Это защищает историю продаж.
Маркеры интеграций: Поля moySkladId и cdekId в модели Order явно подтверждают запланированный поток данных "Заказ -> МойСклад -> СДЭК".
Домен "Пользователи":
Архитектура: Центральная модель User связана со всем, что касается e-commerce (CartItem, WishlistItem, Address).
Маркер безопасности: Явно видны поля для шифрования (name_encrypted, email_encrypted) и хэширования (email_hash). Это прямое подтверждение реализации системы защиты PII.
Маркер Auth.js: Модели Account, Session, VerificationToken и др. — это каноническая реализация схемы для next-auth с PrismaAdapter.
Домен "Поддержка":
Архитектура: Это не просто форма обратной связи, а полноценная тикет-система с моделями SupportTicket, SupportMessage, SupportAgent. Это значительная часть функционала приложения.
Домен "Система":
Архитектура: Содержит продвинутые служебные модели.
Маркеры: FilterPreset — бэкенд для сложной системы фильтров. SystemSetting — гибкое key-value хранилище для настроек. TemporaryReply — модель для временного хранения ответов, вероятно, для админ-бота, что является умным решением для управления состоянием в асинхронной среде.
2. Ключевые архитектурные выводы:
Схема готова к сложному E-commerce: Она описывает не просто "витрину", а комплексную систему с тикетами поддержки, избранным, корзиной, адресами и измерениями пользователей.
Продумана целостность данных: Использование onDelete: Restrict, onDelete: Cascade и уникальных ограничений (@@unique) говорит о том, что схема спроектирована для предотвращения "мусорных" или неконсистентных данных.
Схема подтверждает все наши предыдущие гипотезы: Интеграция с "МойСклад", шифрование PII, использование next-auth, наличие тикет-системы — все это заложено в структуре данных.
Монолитность: Вся бизнес-логика (продукты, пользователи, заказы, поддержка) описана в рамках одной схемы, что приводит к созданию единой монолитной базы данных. Это подтверждает твои опасения по поводу масштабируемости.
[+] Директория /public (Общий анализ)
Тип: Директория для статических ассетов.
Назначение: Хранение файлов, которые должны быть доступны напрямую через URL (изображения, шрифты, favicon.ico и т.д.).
1. Текущее содержимое:
/public/*.png: Набор изображений (Фото - 1.png, placeholder.png и т.д.). Статус: Legacy. Являются "заглушками" с ранних этапов разработки.
/public/images/: Содержит неиспользуемые изображения. Статус: Legacy.
/public/uploads/: Содержит изображения, загруженные в ходе тестирования функционала загрузки файлов. Статус: Legacy / Тестовые данные.
2. Ключевые архитектурные выводы:
Локальное хранилище: Проект на данный момент использует локальную директорию /public/uploads как место для сохранения пользовательских изображений.
Проблема масштабируемости: Хранение загружаемых пользователем файлов внутри репозитория и деплоя является антипаттерном для серьезных, масштабируемых приложений. Это приводит к раздуванию репозитория и, что важнее, на платформах вроде Vercel файловая система является эфемерной (временной). Это означает, что при следующем деплое или перезапуске сервера все загруженные файлы будут удалены.
Отсутствие структуры: Текущая структура папки неорганизованна и не отражает будущие потребности проекта.
[+] src/middleware.ts
Тип: Конфигурация Next.js Edge Middleware.
Назначение: Выполняет роль "диспетчера" или "маршрутизатора" запросов на основе домена, направляя их на правильный "внутренний" маршрут в приложении.
1. Архитектура на NextResponse.rewrite:
Маркер: В файле используется исключительно метод NextResponse.rewrite(). Отсутствуют NextResponse.redirect().
Техническое следствие: Это каноническая реализация мультидоменной архитектуры на Vercel. rewrite "бесшовно" показывает пользователю контент из другого пути, не меняя URL в браузере. Это предотвращает потерю сессии и обеспечивает чистые URL.
2. Логика маршрутизации:
Сценарий 1: Админский домен (admin.kyanchir.ru)
Действие: Любой запрос к этому домену (например, admin.kyanchir.ru/dashboard) внутренне перенаправляется на путь /admin/dashboard.
Вывод: Next.js рендерит страницы из папки /src/app/admin, в то время как пользователь видит только чистый домен администратора.
Сценарий 2: Основной домен (kyanchir.ru)
Действие: Если пользователь пытается получить доступ к пути, начинающемуся с /admin на основном домене, ему показывается страница 404.
Вывод: Это мера для обеспечения чистоты маршрутов и предотвращения путаницы. Пути админки доступны только через админский домен.
Игнорирование: Middleware настроен так, чтобы игнорировать запросы к API, статическим файлам и ассетам (_next, api, favicon.ico), что является правильной практикой для оптимизации производительности.
3. Ключевые архитектурные выводы:
"Диспетчер, а не Охранник": Этот файл идеально реализует принцип, описанный в нашей "Конституции". Его единственная задача — маршрутизация. В нем полностью отсутствует логика проверки аутентификации или ролей.
Делегирование Безопасности: Анализ этого файла подтверждает, что вся логика защиты (проверка, является ли пользователь админом) была сознательно перенесена из middleware вглубь приложения, вероятнее всего, в /src/app/admin/layout.tsx, где она выполняется с помощью await auth(). Это более надежное и правильное решение.
Жесткая привязка к доменам: Доменные имена admin.kyanchir.ru и kyanchir.ru захардкожены прямо в файле.
[+] src/app/layout.tsx
Тип: Корневой Layout-компонент Next.js.
Назначение: Определяет фундаментальную HTML-структуру (<html>, <head>, <body>) для всех без исключения страниц приложения. Является точкой для инъекции глобальных стилей, шрифтов, скриптов и провайдеров.
1. Mobile-First и PWA Конфигурация:
Маркер: В <head> присутствует расширенный набор <meta> тегов:
viewport: maximum-scale=1, user-scalable=no, viewport-fit=cover — эти параметры нацелены на создание "нативного" опыта в мобильных браузерах, отключая зум и используя всю площадь экрана на устройствах с "челкой".
apple-mobile-web-app-capable / mobile-web-app-capable: Прямое указание браузерам, что сайт может быть добавлен на главный экран и должен вести себя как приложение (PWA).
Вывод: Архитектура с самого начала закладывает фундамент для полноценного Прогрессивного Веб-Приложения, как это и было описано в "Конституции".
2. Интеграция с Telegram Mini App:
Маркер: С помощью <Script> с высокой стратегией (beforeInteractive) загружается официальный скрипт telegram-web-app.js.
Техническое следствие: Это обеспечивает максимально раннюю инициализацию API Telegram Mini App, что критически важно для бесшовного взаимодействия фронтенда с нативным клиентом Telegram.
3. Архитектурное Делегирование (Ключевое решение):
Маркер: В коде явно указано, что компонент AppCore (вероятно, содержавший общую разметку, Header, Footer) был удален из этого корневого layout.
Техническое следствие: RootLayout теперь является минималистичной, "голой" оболочкой. Он не навязывает никакого UI. Его единственная задача — предоставить <html> и <body> и обернуть дочерние элементы в глобальные провайдеры (AuthProvider).
Вывод: Это сознательное и важнейшее архитектурное решение. Оно позволяет создавать полностью независимые дочерние layout'ы (для сайта /(site)/layout.tsx и для админки /admin/layout.tsx), каждый со своим уникальным UI, без наследования общих элементов. Это и есть фундамент для разделения клиентской и административной частей.
4. Глобальные Провайдеры и Шрифты:
Шрифты: Корректно подключаются через CSS-переменные, что подтверждает связку с tailwind.config.ts.
Аутентификация: Все приложение обернуто в AuthProvider, что делает данные о сессии доступными во всех компонентах.
Scroll Restoration: Внедрен скрипт history.scrollRestoration = "manual". Это является решением распространенной проблемы в SPA/Next.js, когда браузер некорректно восстанавливает позицию прокрутки при навигации.
[+] src/app/globals.css
Тип: Глобальная таблица стилей.
Назначение: Определяет базовые стили для всего приложения, сбрасывает стили браузера, объявляет глобальные CSS-переменные (Design Tokens) и содержит кастомные утилитарные классы.
1. Фундамент Design System (@layer base):
Design Tokens (:root): Вся цветовая палитра и ключевые метрики (например, mobile-footer-height) вынесены в глобальные CSS-переменные. Это централизует управление дизайном и является каноничной практикой. Имена переменных (--brand-lilac-color) семантичны и соответствуют tailwind.config.ts.
Стили <body>:
Маркер (Mobile/PWA): Использование overscroll-behavior-y: contain и padding с env(safe-area-inset-*) прямо указывает на то, что стили заточены под создание нативного опыта на мобильных устройствах, особенно iOS (учет "челки").
Продвинутая CSS-логика (:has):
Маркер: Использование современного селектора :has(.mobile-sticky-footer) для динамического изменения переменной --mobile-footer-height — это продвинутая техника, которая позволяет стилизовать родителя (body) в зависимости от наличия дочернего элемента.
2. Архитектурный Маркер (Потенциальный Конфликт): Двойная Система Типографики
Наблюдение: В этом файле определены глобальные стили для тегов h1, h2, h3, использующие clamp() для "резиновой" верстки.
Конфликт: В то же время, в tailwind.config.ts у нас есть кастомный плагин, который генерирует утилитарные классы (.text-h1, .text-h2) для управления типографикой.
Техническое следствие: Это создает два конкурирующих источника правды для стилизации заголовков. Разработчик может использовать просто тег <h1> и получить один результат, а может использовать <p class="text-h1"> и получить другой. Это может привести к визуальной неконсистентности и усложняет поддержку.
3. Глобальные Утилиты и Анимации:
Определены кастомные утилиты (.scrollbar-hide) и анимации (.animate-fade-pulse), которые доступны во всем приложении.
Содержатся стили для кастомизации вендорных библиотек (Swiper) и сброс стилей для input[type="number"].
4. Ключевые архитектурные выводы:
Централизованная Дизайн-Система: Файл является ядром визуальной системы, определяя токены и базовые стили.
Фокус на Mobile/PWA: Множество правил нацелено на создание "нативного" пользовательского опыта.
Технический Долг: Существует явная проблема с двойной системой управления типографикой, которую необходимо унифицировать.
Современный CSS: Проект не боится использовать современные и мощные CSS-возможности (:has, clamp, env).
[+] src/app/fonts.ts
Тип: Модуль конфигурации шрифтов.
Назначение: Централизованно определяет и настраивает все шрифты, используемые в приложении, с помощью встроенной в Next.js системы оптимизации next/font.
1. Конфигурация шрифтов:
Источник: Все шрифты (Unbounded, Manrope, PT_Mono) загружаются из next/font/google.
Архитектура: Для каждого логического типа текста (heading, body, mono) создается отдельная переменная.
Оптимизация:
subsets: ['cyrillic', 'latin']: Загружаются только необходимые для проекта поднаборы символов (кириллица и латиница), что уменьшает размер шрифтовых файлов.
display: 'swap': Браузер сначала отображает текст системным шрифтом, а затем заменяет его на загруженный. Это улучшает метрику LCP (Largest Contentful Paint).
variable: Ключевой маркер. Шрифты не применяются глобально, а подключаются через CSS-переменные (--font-heading, --font-body, --font-mono).
2. Ключевые архитектурные выводы:
Каноничная интеграция: Проект использует рекомендованный и наиболее производительный способ работы со шрифтами в Next.js. next/font автоматически оптимизирует шрифты, инлайнит их в CSS и предотвращает "прыжки" макета (CLS).
Связь с tailwind.config.ts: CSS-переменные, определенные здесь (--font-heading и т.д.), напрямую используются в tailwind.config.ts для создания utility-классов (font-heading). Это пример идеальной связки между конфигурационными файлами.
Семантическое разделение: Шрифты разделены по их семантической роли (заголовок, основной текст, моноширинный), а не по названию. Это гибкая архитектура, которая позволяет легко заменить, например, шрифт всех заголовков, изменив всего одну строку в этом файл
[+] src/app/favicon.svg и src/app/favicon.ico
Тип: Статические ассеты (иконки).
Назначение: Определяют иконку сайта, которая отображается во вкладке браузера, закладках и других интерфейсах. Их размещение в корне /src/app является стандартной практикой для Next.js App Router.
(продолжаем анализ)
[+] src/app/(site)/layout.tsx
Тип: Layout-компонент для Route Group.
Назначение: Является визуальным скелетом (Header, Footer и т.д.) исключительно для публичной, клиентской части сайта.
1. Архитектура Route Group:
Маркер: Файл находится в директории (site).
Техническое следствие: Это Route Group. Данный layout применяется ко всем страницам внутри этой группы (/, /profile, /catalog), но полностью игнорируется маршрутами за ее пределами (например, /admin).
Вывод: Это подтверждает архитектурное решение о полной изоляции UI клиентской части от административной.
2. Граница Клиентского Компонента ('use client'):
Маркер: Директива 'use client' размещена в самом верху файла.
Техническое следствие: Весь этот layout и все его дочерние компоненты (включая AppCore и все страницы сайта) становятся частью клиентского бандла.
Вывод: Это важное архитектурное решение, указывающее на то, что общая оболочка сайта (шапка, футер) является высокоинтерактивной и требует доступа к состоянию (useState), хукам (useEffect) и браузерным API с самого начала.
3. Делегирование ответственности:
Архитектура: Компонент SiteLayout выполняет только одну задачу: оборачивает дочерние страницы в компонент <AppCore>.
Вывод: Вся реальная логика и структура UI (шапка, футер, логика скролла, как указано в комментарии) инкапсулирована внутри <AppCore>. SiteLayout — это просто "переходник", а AppCore — это настоящий "каркас" сайта.
+] src/app/(site)/page.tsx
Тип: React Server Component (RSC), точка входа для главной страницы.
Назначение: Отвечает за получение всех необходимых данных для главной страницы (продукты, конфигурация фильтра), их подготовку и передачу в клиентский компонент для рендеринга.
1. Стратегия рендеринга и получения данных:
Маркер (RSC): Файл является async функцией, что подтверждает его выполнение исключительно на сервере.
Маркер (Динамический рендеринг): export const dynamic = 'force-dynamic'. Это ключевое архитектурное решение. Оно принудительно отключает любое кэширование и заставляет страницу полностью пересоздаваться на сервере при каждом запросе. Это гарантирует максимальную свежесть данных, но создает высокую нагрузку на сервер.
Маркер (Эффективность): Данные о продуктах и фильтрах запрашиваются одновременно с помощью Promise.all. Это правильная практика для параллелизации запросов.
2. Логика бизнес-правил:
Маркер (Фильтр продуктов): Присутствует закомментированный, но критически важный фильтр where: { status: 'PUBLISHED' }. Комментарий подтверждает, что в режиме разработки он отключен для отображения всех товаров, включая черновики.
Маркер (Представление товара): Данные для карточки товара (цена, изображения) берутся из первого варианта (product.variants[0]). Это важное бизнес-правило, определяющее, как "составной" товар представляется в каталоге.
Маркер (Конфигурация фильтра): Категории для фильтра на главной странице берутся не из общей таблицы категорий, а из специальной модели FilterPreset по жестко заданному имени 'main-store-filter'. Это подтверждает, что фильтры на сайте — это управляемые, курируемые наборы, а не просто список всех существующих категорий.
3. Архитектурный паттерн "Кухня и Зал":
Реализация: Этот компонент является идеальной реализацией паттерна. Он выполняет всю "черновую" работу на сервере ("кухня"):
Прямое обращение к базе данных (prisma).
Получение сырых данных.
Трансформация данных в удобный для фронтенда формат (ProductWithInfo).
Затем он передает уже готовые, "чистые" данные в виде props в клиентский компонент <HomePageClient>, который отвечает только за отображение и интерактивность ("зал").
[+] src/app/(site)/loading.tsx
Тип: Специальный файл Next.js (UI индикатор загрузки).
Назначение: Автоматически отображается в рамках Suspense, пока данные для страниц внутри Route Group (site) загружаются на сервере. Обеспечивает мгновенный отклик и улучшает UX.
1. Архитектура и Расположение:
Маркер (Route Group): Файл находится в (site).
Техническое следствие: Этот индикатор загрузки работает только для страниц публичного сайта и не затрагивает административную панель, у которой может быть своя (или отсутствовать) логика загрузки.
2. UI/UX Реализация:
'use client': Компонент является клиентским, так как использует хуки.
Блокировка скролла: С помощью useEffect реализована блокировка прокрутки страницы на время загрузки. Это продуманное UX-решение, предотвращающее взаимодействие с незагруженным контентом.
Визуальный эффект: Используется эффект "матового стекла" (backdrop-blur-sm) и анимированный логотип с кастомной анимацией (animate-fade-pulse), что говорит о высоком внимании к деталям в UI.
3. Ключевой Архитектурный Маркер (Контекстно-зависимый UI):
Логика: Компонент использует хук usePathname для определения текущего URL.
Действие: На основе URL динамически изменяется z-index компонента (z-[155] для главной страницы и z-[150] для остальных).
Вывод: Это неопровержимое доказательство существования сложной, контекстно-зависимой верстки. Оно означает, что у хедера на главной странице (/) и у хедеров на других страницах разная архитектура или, как минимум, разный z-index. Логика загрузчика жестко связана с этой реализацией.
[+] src/app/(site)/verify-email/page.tsx
Тип: Клиентский компонент для выполнения auth-флоу.
Назначение: Обрабатывает финальный шаг верификации email. Пользователь попадает на эту страницу после клика по ссылке в письме. Страница извлекает токен из URL, отправляет его на бэкенд для проверки и информирует пользователя о результате.
1. Архитектурный паттерн:
Client-Side Fetching: Компонент использует директиву 'use client' и хук useEffect для выполнения API-запроса после рендеринга. Это стандартный и корректный паттерн для страниц, которые должны реагировать на параметры в URL и выполнять действия на стороне клиента.
Использование Suspense: Компонент VerifyEmailContent, который использует хук useSearchParams, обернут в <Suspense>. Это является каноничной и обязательной практикой в Next.js App Router для корректной работы с параметрами URL.
UI как конечный автомат: Компонент реализован как простая, но надежная state-машина с тремя состояниями (loading, success, error), что обеспечивает понятный и предсказуемый пользовательский опыт для каждого этапа процесса.
2. Безопасность и Поток Данных:
Четкая граница "Клиент-Сервер": Это ключевой архитектурный маркер.
Клиент: Только считывает token из URL и отправляет его на сервер.
Сервер: Вся логика валидации токена (проверка существования, срока действия, сопоставление с пользователем) происходит на бэкенде, по адресу /api/auth/verify-token.
Вывод: Реализована безопасная архитектура. Чувствительная логика проверки инкапсулирована на сервере и не доступна клиенту.
3. User Experience (UX):
Изолированный UI: Страница имеет собственный, минималистичный макет, который не включает общую шапку и футер сайта. Это фокусирует внимание пользователя на процессе верификации.
Продуманный флоу:
Пользователь получает мгновенную обратную связь о статусе проверки.
В случае успеха происходит автоматический редирект в профиль через 3 секунды, что обеспечивает плавный переход.
В случае ошибки пользователю предоставляется понятное сообщение и ссылка для возврата.
[+] src/app/(site)/support/page.tsx
Тип: Клиентский компонент (Форма обратной связи).
Назначение: Предоставляет пользователям интерфейс для отправки обращений в службу поддержки, которые, в свою очередь, должны создавать тикеты в "Домене Поддержки", описанном в schema.prisma.
1. Архитектурный паттерн:
Управляемый компонент: Форма полностью реализована на React с использованием состояния (useState) для управления значениями полей. Это стандартный и надежный паттерн.
Client-Side Fetching: Как и страница верификации, этот компонент является клиентским ('use client') и использует fetch для отправки данных на API-маршрут /api/support-form.
Четкая типизация: Для состояния формы (FormState) и ответа от сервера (ServerResponse) используются явные TypeScript-типы, что повышает надежность и читаемость кода.
2. Безопасность и Валидация:
Клиентская валидация: Реализована базовая проверка на клиенте на наличие обязательных полей. Это улучшает UX, предоставляя мгновенную обратную связь.
Делегирование на сервер: Основная логика обработки и валидации данных делегирована API-маршруту /api/support-form. Это правильная архитектура, так как клиентской валидации доверять нельзя.
3. User Experience (UX):
Обратная связь: Реализована полная система обратной связи для пользователя:
Кнопка отправки блокируется и меняет текст во время запроса (isSubmitting).
После ответа от сервера отображается понятное сообщение об успехе или ошибке.
Очистка формы: В случае успешной отправки форма автоматически очищается, готовя ее к новому вводу.
4. Ключевые архитектурные выводы:
Подтверждение тикет-системы: Эта форма является "входными воротами" для создания сущностей SupportTicket и SupportMessage в базе данных.
Классическая архитектура "Форма -> API": Проект использует проверенный временем и надежный подход для обработки форм. Данные собираются на клиенте и отправляются на выделенный серверный эндпоинт для обработки.
Высокое качество реализации: Компонент хорошо структурирован, полностью типизирован, обеспечивает отличный UX и следует правильным паттернам безопасности.
[+] Директория src/app/(site)/profile (Полный анализ модуля)
Тип: Полнофункциональный модуль управления профилем пользователя.
Назначение: Предоставляет пользователю интерфейс для просмотра, редактирования своих данных, смены пароля и выполнения других действий, связанных с аккаунтом.
1. Архитектурный паттерн "Кухня-Зал" (Образцовая реализация):
Этот модуль является идеальной демонстрацией архитектурного принципа разделения серверной и клиентской логики.
"Кухня" (page.tsx - Server Component):
Выполняет роль "охранника" и "подготовителя".
Безопасность: Проверяет наличие сессии на сервере и делает редирект, если пользователь не авторизован.
Подготовка данных: Получает из БД зашифрованные данные пользователя (name_encrypted, email_encrypted).
Дешифровка: Использует серверную утилиту decrypt() для расшифровки PII.
Передача: Передает уже чистые, расшифрованные данные в клиентский компонент.
"Зал" (ProfileClient.tsx - Client Component):
Получает полностью готовые, безопасные данные через props.
Отвечает за весь UI и интерактивность: управление состоянием редактирования, отображение ошибок/успеха, обработка кликов.
Является "компонентом-оркестратором", который управляет более мелкими, специализированными UI-компонентами (ProfileHeader, EditProfileForm и т.д.).
2. Потоки данных и безопасность (Современный подход):
Чтение: Поток данных при чтении абсолютно безопасен: Server -> Prisma -> decrypt() -> Client. Секреты никогда не покидают сервер.
Запись (Server Actions):
Маркер: Для изменения данных (профиль, пароль) используются Server Actions (actions.ts). Это современный, безопасный и эффективный паттерн.
Безопасность: Внутри Server Action данные от клиента сначала валидируются с помощью zod, а затем шифруются (encrypt()) перед записью в БД.
Состояние UI: Клиентский компонент использует хук useTransition для отслеживания состояния выполнения Server Action, что позволяет элегантно обрабатывать pending состояния (например, блокировать кнопку).
Неконсистентность (Маркер для рефакторинга):
В то время как обновление профиля использует Server Actions, отправка кода верификации реализована через "старый" паттерн — fetch к API-маршруту (/api/auth/send-verification-code).
3. Ключевые архитектурные выводы:
Модульность и декомпозиция: Функционал страницы профиля грамотно разбит на иерархию компонентов: page.tsx (данные) -> ProfileClient.tsx (логика) -> ProfileHeader.tsx, EditProfileForm.tsx (UI).
Полный цикл шифрования: Этот модуль наглядно демонстрирует полный, замкнутый и безопасный цикл работы с PII: дешифровка на сервере для чтения, шифрование на сервере для записи.
Высокий уровень готовности: Модуль содержит не только базовый функционал, но и заготовки для будущих фич (привязка Telegram, управление сессиями, удаление аккаунта), что говорит о продуманной архитектуре.
SignOutButton.tsx: Вынос логики выхода в отдельный, сфокусированный компонент — это чистая и правильная практика.
[+] src/app/(site)/product/[id]/page.tsx
Тип: Динамическая страница (React Server Component).
Назначение: Отвечает за получение, обработку и отображение данных для конкретного товара по его id.
1. Стратегия рендеринга и получения данных:
Маркер (RSC): Файл является async функцией, что подтверждает его выполнение на сервере.
Маркер (Динамический рендеринг): export const dynamic = 'force-dynamic'. Как и на главной странице, здесь принудительно отключено кэширование. Каждая загрузка страницы товара вызывает новый запрос к базе данных.
Обработка ошибок: Корректно используется функция notFound() из Next.js. Если товар с указанным id не найден, пользователю будет показана страница 404.
2. Ключевая бизнес-логика (Сортировка размеров):
Маркер: В компоненте определена константа SIZE_ORDER (['XS', 'S', 'M', ...]).
Действие: После получения данных из БД, компонент принудительно пересортировывает массив размеров (variant.sizes) в соответствии с порядком, заданным в SIZE_ORDER.
Вывод: Это важное архитектурное решение, которое гарантирует, что на всех карточках товаров размеры всегда будут отображаться в едином, предсказуемом и логичном для пользователя порядке (от меньшего к большему), независимо от того, в каком порядке они хранятся в базе данных.
3. Архитектурный паттерн "Кухня и Зал":
Реализация: Компонент является еще одним образцовым примером этого паттерна.
"Кухня": Выполняет всю серверную работу:
Запрашивает данные из prisma, включая все необходимые связи (variants, images, sizes).
Применяет бизнес-логику (сортировка размеров).
"Зал": Передает полностью подготовленный и отсортированный объект product в клиентский компонент <ProductDetails>, который отвечает только за его отображение.
4. Потенциальные проблемы:
Производительность: Стратегия 'force-dynamic' гарантирует свежесть данных (остатков), но создает значительную нагрузку на БД, так как даже самая популярная страница товара никогда не будет кэшироваться.
"Магическая" константа: Массив SIZE_ORDER захардкожен прямо в файле страницы. Если в проекте появится новый размер или изменится порядок, придется искать и редактировать эту константу здесь, что не является надежной практикой.
[+] src/app/(site)/catalog/page.tsx
Тип: React Server Component (RSC), страница каталога.
Назначение: Отвечает за получение полного списка опубликованных товаров, их подготовку и передачу в клиентский компонент для отображения.
1. Стратегия рендеринга и получения данных:
Маркер (RSC): Файл является async функцией.
Маркер (Динамический рендеринг): export const dynamic = 'force-dynamic'. Как и на других ключевых страницах, здесь принудительно отключено кэширование, что гарантирует актуальность данных, но создает высокую нагрузку.
2. Ключевая бизнес-логика:
Фильтрация: Запрос к prisma явно фильтрует товары по статусу 'PUBLISHED'. Это гарантирует, что в публичный каталог не попадут черновики.
Представление товара: Используется тот же паттерн, что и на главной странице: данные для карточки товара (цена, изображения) берутся из первого варианта (product.variants[0]).
Архитектурный Маркер (Критический "Code Smell"):
Логика: В коде присутствует жестко захардкоженное условие: if (product.name === 'Комплект двойка') { ... }.
Техническое следствие: Это очень хрупкое и немасштабируемое решение. Любое изменение названия товара в "МойСклад" сломает эту логику. Добавление других подобных "особенных" товаров потребует изменения кода.
Вывод: Это является серьезным техническим долгом, который нарушает принцип разделения данных и представления.
3. Архитектурные Неконсистентности:
Паттерн "Кухня и Зал": Компонент корректно следует паттерну, подготавливая данные и передавая их в <CatalogContent>.
Нарушение принципа "Layout — Хозяин Контейнера":
Логика: Этот компонент создает свой собственный <div class="container mx-auto ...">.
Техническое следствие: Это противоречит архитектурному принципу, который мы вывели ранее, где за создание основного контейнера должен отвечать AppCore.tsx или layout.tsx. Это может привести к проблемам с версткой (двойные отступы) и усложняет поддержку.
[+] src/app/(site)/auth/verify-email/page.tsx
Тип: Клиентский компонент (Альтернативный флоу верификации email).
Назначение: Как и его "двойник", этот компонент обрабатывает верификацию email через токен, полученный из URL.
1. Архитектурный Маркер (Критическая Проблема: Дублирование Функционала):
Наблюдение: В проекте существуют два отдельных и независимых модуля для верификации email:
.../(site)/verify-email/page.tsx (проанализирован ранее)
.../(site)/auth/verify-email/page.tsx (этот файл)
Сравнение:
API-эндпоинт: Этот файл вызывает /api/auth/verify-email. Другой файл вызывает /api/auth/verify-token. Это два разных бэкенд-маршрута для одной и той же задачи.
Параметры: Этот файл требует и token, и email. Другой — только token.
Качество реализации: Этот компонент имеет более простую логику и менее проработанный UI по сравнению с его "двойником", который использует state-машину и имеет более качественное оформление.
Вывод: Наличие двух параллельных систем для одной критической функции является серьезным техническим долгом. Это приводит к путанице, усложняет поддержку и указывает на то, что один из этих флоу, скорее всего, является устаревшим (legacy).
2. Анализ компонента:
Паттерн: Используется стандартный паттерн client-side fetch в useEffect для отправки токена на бэкенд.
UX: Реализован минималистичный UX с текстовым сообщением о статусе операции и автоматическим редиректом в профиль в случае успеха.
Код: В коде присутствует неиспользуемый импорт signIn, что может подкреплять гипотезу об устаревшем коде.
+] src/app/(site)/(auth)/layout.tsx
Тип: Layout-компонент для вложенной Route Group.
Назначение: Определяет "пустой" макет специально для страниц аутентификации (логин, регистрация, сброс пароля и т.д.).
1. Архитектура Route Group:
Маркер: Файл находится в директории (auth).
Техническое следствие: Это вложенная Route Group. Next.js применяет этот layout ко всем страницам внутри (auth), но сам путь /(auth) не становится частью URL.
Ключевая функция: Этот layout переопределяет родительский (site)/layout.tsx. Он не вызывает <AppCore>, тем самым предотвращая отображение общей шапки, футера и другой UI-обвязки сайта на страницах аутентификации.
2. Реализация:
Компонент является "pass-through" компонентом. Он просто рендерит дочерние элементы ({children}) без какой-либо дополнительной обертки.
Это означает, что каждая страница внутри (auth) (например, login/page.tsx) несет полную ответственность за свою собственную верстку от <html> до подвала.
3. Ключевые архитектурные выводы:
UI Изоляция (Лучшая практика): Это каноничная и абсолютно правильная реализация для auth-страниц. Она создает сфокусированный пользовательский опыт, удаляя все отвлекающие элементы навигации.
Чистота и простота: Решение максимально простое и декларативное. Оно не добавляет логики, а использует саму файловую структуру Next.js для управления сложными UI-сценариями.
Подтверждение иерархии: Этот файл подтверждает, что в проекте есть как минимум два уровня макетов: глобальный (src/app/layout.tsx), макет сайта ((site)/layout.tsx) и изолированный макет для аутентификации ((auth)/layout.tsx).
[+] src/app/(site)/(auth)/reset-password/page.tsx
Тип: React Server Component (RSC), страница сброса пароля.
Назначение: Является целевой страницей для ссылки из email о сбросе пароля. Ее задача — валидировать токен на сервере и, в случае успеха, отобразить форму для ввода нового пароля.
1. Архитектурный паттерн (Безопасность прежде всего):
"Server-Side Validation First": Это ключевой и образцовый паттерн безопасности.
Компонент (ResetPasswordPage) выполняется полностью на сервере.
Он немедленно вызывает async функцию validateToken, которая напрямую обращается к базе данных (prisma).
Форма для ввода нового пароля (<ResetPasswordForm>) рендерится только после того, как сервер подтвердил, что предоставленный токен существует, валиден и не истек.
Вывод: Этот подход предотвращает любые ненужные операции на клиенте и не раскрывает UI для смены пароля неавторизованным запросам.
2. Архитектурный паттерн "Кухня и Зал":
"Кухня" (page.tsx): Выполняет всю серверную логику проверки. Он принимает решение: "Можно ли этому запросу доверять?".
"Зал" (<ResetPasswordForm>): Является клиентским компонентом, который получает валидный token в качестве props. Его единственная задача — предоставить UI для ввода пароля и вызвать Server Action для его обновления.
3. Структура кода:
Декомпозиция: Логика и UI четко разделены.
validateToken: Чистая серверная функция, отвечающая только за валидацию.
MessageDisplay: Переиспользуемый компонент для отображения статуса/ошибок.
ResetPasswordForm: Отдельный компонент, инкапсулирующий логику самой формы.
[+] src/app/(site)/(auth)/register/page.tsx
Тип: Клиентский компонент (Многошаговая форма регистрации).
Назначение: Предоставляет пользователю пошаговый интерфейс для создания нового аккаунта, сбора данных, валидации и последующей автоматической авторизации.
1. Архитектурный паттерн "Multi-Step Wizard":
Маркер: Компонент использует состояние step для разделения процесса регистрации на три логических этапа: (1) Email -> (2) Пароль -> (3) Персональные данные.
Вывод: Это осознанное UX-решение, направленное на снижение когнитивной нагрузки на пользователя и повышение конверсии в регистрацию.
2. Архитектурный паттерн "Register & Auto-Login":
Маркер (Ключевой): Функция handleRegisterSubmit выполняет две последовательные асинхронные операции:
fetch('/api/auth/register'): Создает запись о пользователе в базе данных.
signIn('credentials', ...): Сразу после успешного создания аккаунта, выполняет попытку входа с теми же данными.
Вывод: Реализован флоу, который обеспечивает бесшовный опыт: после регистрации пользователь сразу оказывается в своей учетной записи без необходимости повторного входа. Однако, вся логика этой сложной оркестрации выполняется на клиенте, что делает ее потенциально хрупкой.
3. Безопасность и Валидация:
Клиентская валидация: Присутствует базовая валидация на клиенте (формат email, длина пароля).
Делегирование на сервер: Основная, авторитетная валидация и создание пользователя делегированы API-маршруту /api/auth/register.
4. User Experience (UX):
Продуманные детали: Реализованы такие UX-улучшения, как иконки для показа/скрытия пароля и кнопка быстрой очистки поля.
Альтернативный путь: Присутствует явная кнопка "Войти через Telegram", подтверждающая наличие альтернативного флоу регистрации/авторизации.
5. Стилизация:
Маркер: В компоненте используется тег <style jsx>.
Вывод: Это локальная, инкапсулированная стилизация, специфичная для этого компонента. Это отличается от глобального подхода с utility-классами и указывает на то, что для сложных компонентов могут применяться отдельные стилистические решения.
[+] src/app/(site)/(auth)/login/page.tsx
Тип: Клиентский компонент (Форма входа).
Назначение: Предоставляет пользователю интерфейс для входа в систему.
1. Ключевой Архитектурный Маркер: Кастомный Двухшаговый Логин
Наблюдение: Логика handleLoginSubmit — это не стандартный вызов signIn от NextAuth. Это кастомный, двухэтапный процесс:
Шаг 1 (Валидация): Сначала отправляется fetch-запрос на /api/auth/validate-credentials для проверки пары email + пароль. Этот эндпоинт не создает сессию, а только подтверждает, что данные верны.
Шаг 2 (Отправка кода): Только в случае успеха первого шага, отправляется второй fetch-запрос на /api/auth/send-login-code, который инициирует отправку кода подтверждения на email пользователя.
Вывод: В проекте реализована повышенная безопасность входа, требующая не только знания пароля, но и последующего подтверждения через email при каждой попытке входа. Это не стандартная 2FA, а скорее "сессионный" двухшаговый логин.
2. Архитектурный паттерн "Client-Side Orchestration":
Реализация: Вся сложная логика "сначала проверь, потом отправь, потом перенаправь" управляется напрямую с клиента.
Следствие: Это делает флоу потенциально хрупким. Если второй запрос (send-login-code) по какой-либо причине не удастся, пользователь останется на странице входа в неопределенном состоянии, хотя его пароль был верным.
3. User Experience (UX):
"Запомнить меня": Реализована классическая функция "Запомнить меня", которая корректно использует localStorage для сохранения email пользователя между сессиями.
Обратная связь: Компонент обрабатывает и отображает как ошибки, так и сообщения об успехе (например, после регистрации), что улучшает пользовательский опыт.
Продуманный UI: Присутствуют мелкие, но важные UX-детали, такие как иконки для показа/скрытия пароля и очистки полей.
+] src/app/(site)/(auth)/login/verify-request/page.tsx
Тип: Статическая информационная страница (React Server Component).
Назначение: Отображается пользователю после того, как он запросил верификацию по email (вероятнее всего, в процессе регистрации), чтобы сообщить ему о необходимости проверить почту.
1. Архитектурный Маркер (Критическая Неконсистентность Флоу):
Наблюдение: Текст на странице говорит: "Мы отправили ссылку для подтверждения на ваш email".
Конфликт: Это напрямую противоречит логике, которую мы проанализировали в login/page.tsx, где реализован двухшаговый вход с отправкой кода, а не ссылки.
Вывод: Существование этой страницы является неопровержимым доказательством наличия в проекте как минимум двух параллельных, конкурирующих и абсолютно разных механизмов аутентификации/верификации: один на основе ссылок, другой — на основе кодов. Это серьезная архитектурная проблема, указывающая на то, что один из флоу является устаревшим.
2. Анализ компонента:
Тип рендеринга: Компонент является серверным (нет 'use client'). Это правильно, так как страница полностью статична и не требует интерактива.
UX: Страница предоставляет четкую и понятную инструкцию для пользователя и предлагает ясный следующий шаг (кнопка "За покупками"). UI, как и у других auth-страниц, изолирован от основной навигации сайта.
3. Ключевые архитектурные выводы:
Подтверждение технического долга: Этот файл — главный "улик" в расследовании архитектурных неконсистентностей. Он подтверждает, что система аутентификации не является единой.
Простота и фокус: Сам по себе компонент реализован правильно для своей задачи — он простой, статический и информативный. Проблема не в его коде, а в самом факте его существования параллельно с другой логикой.
[+] src/app/(site)/(auth)/login/verify-code/page.tsx
Тип: Клиентский компонент (Второй шаг двухфакторного входа).
Назначение: Является целевой страницей после ввода правильного пароля. Ее задача — принять 6-значный код, проверить его на сервере и, в случае успеха, завершить процесс аутентификации, создав сессию.
1. Ключевой Архитектурный Маркер: "Pass-Through" Аутентификация
Наблюдение: Логика handleSubmit — это сложная, многоступенчатая клиентская оркестрация, которая раскрывает суть кастомного auth-флоу:
Шаг 1 (Верификация кода): Сначала отправляется fetch-запрос на /api/auth/verify-login-code с email и кодом. Бэкенд проверяет код и, в случае успеха, возвращает полные данные пользователя.
Шаг 2 (Создание сессии): Затем, на клиенте, вызывается signIn('credentials', ...) из NextAuth. Но вместо пароля ему передаются уже верифицированные данные пользователя, полученные на первом шаге.
Вывод: Это продвинутое использование credentials провайдера в режиме "pass-through". Клиент говорит NextAuth: "Я уже проверил этого пользователя другим способом (через код), вот его данные, просто создай для него сессию".
2. User Experience (UX):
Высококачественный UI: Компонент для ввода кода реализован с большим вниманием к деталям:
Используется "трюк" с невидимым инпутом и визуальными ячейками, что является лучшей практикой для такого UI.
Присутствует анимация курсора на активной ячейке (animate-pulse).
Продуманный флоу: Реализован функционал повторной отправки кода с 60-секундным кулдауном для предотвращения спама.
3. Архитектурные Недостатки:
Хрупкость: Как и на странице логина, вся сложная логика оркестрации ("сначала проверь, потом создай сессию") выполняется на клиенте. Ошибка сети между двумя этими шагами может привести к неудачному входу, даже если код был верным.
Неконсистентное информирование: Для вывода информационного сообщения ("Мы отправили новый код...") используется состояние error, что семантически неверно и может запутать при поддержке кода.
+] src/app/(site)/(auth)/forgot-password/page.tsx
Тип: React Server Component (RSC), страница-обертка.
Назначение: Отображает статическую "раму" для страницы запроса на восстановление пароля, делегируя всю интерактивную логику отдельному клиентскому компоненту.
1. Архитектурный паттерн (Контейнер / Презентация):
Маркер (RSC): Файл является async функцией (хотя и не использует await), что подтверждает его выполнение на сервере.
Архитектура: Этот компонент является классическим примером "компонента-контейнера". Он не содержит никакой собственной логики или состояния. Его единственные задачи:
Создать общую разметку и стили для страницы (заголовок, логотип, ссылки).
Вставить в эту разметку специализированный, интерактивный компонент <ForgotPasswordForm />.
2. Ключевые архитектурные выводы:
Оптимальное использование RSC: Проект грамотно использует серверные компоненты для рендеринга статического UI, что улучшает производительность и SEO.
Чистая декомпозиция: Вся сложная логика (управление состоянием формы, валидация, отправка запроса) полностью инкапсулирована в дочернем клиентском компоненте <ForgotPasswordForm />. Это делает page.tsx максимально простым, чистым и предсказуемым.
Единый стиль: Страница следует тому же изолированному стилю, что и другие страницы аутентификации, обеспечивая консистентный UX.
[+] src/components/auth/ForgotPasswordForm.tsx
Тип: Клиентский компонент (UI и логика формы).
Назначение: Предоставляет пользователю интерфейс для запроса ссылки на сброс пароля. Является интерактивной частью страницы /forgot-password.
1. Архитектурный паттерн
Классический клиентский компонент: Компонент полностью выполняется на клиенте ('use client'). Он использует хуки useState для управления состоянием формы (введенный email, статус загрузки, статус отправки) и useEffect для реакции на изменения в URL.
Паттерн "Форма -> API Route": Это каноничная реализация "старого" подхода. Вся логика отправки данных инкапсулирована в fetch-запросе к выделенному API-маршруту (/api/auth/password-reset/request).
UI как конечный автомат: Компонент четко управляет своим отображением через состояние isSubmitted. Он существует в двух режимах: "Форма для ввода" и "Сообщение об успехе", что является надежным и предсказуемым UX-паттерном.
2. Безопасность и Поток Данных
Четкая граница "Клиент-Сервер": Компонент следует правильному паттерну безопасности.
Клиент: Только собирает email и отправляет его на сервер.
Сервер (API Route): Вся критическая логика — проверка существования email в базе, генерация уникального токена сброса, запись токена в БД и отправка письма — делегирована бэкенду.
Клиентская валидация: Присутствует базовая проверка на пустое поле email. Это исключительно UX-улучшение, а не мера безопасности.
3. User Experience (UX)
Продуманный флоу: Компонент реализует множество мелких, но важных UX-улучшений:
Предзаполнение Email: Используя useEffect и useSearchParams, компонент "подхватывает" email из параметров URL. Это позволяет другим частям системы (например, странице входа) перенаправить пользователя на сброс пароля с уже заполненным полем, что очень удобно.
Обратная связь: Используется библиотека react-hot-toast для мгновенного информирования пользователя о статусе операции (загрузка, успех, ошибка).
Блокировка UI: Кнопка отправки и поле ввода блокируются (disabled={isLoading}) во время запроса, предотвращая двойные нажатия.
Визуальные детали: Присутствует иконка для быстрой очистки поля ввода, что является хорошей практикой.
Четкий результат: После успешной отправки форма заменяется на понятное сообщение, что исключает путаницу.
4. Связь с родительским компонентом
Этот компонент является "мозгом" и "руками" для своего родителя — серверного компонента forgot-password/page.tsx, который мы проанализировали ранее. Родитель предоставляет только статическую "раму" и заголовок, а вся интерактивность и логика инкапсулированы здесь. Это образцовый пример декомпозиции.
[+] src/components/auth/ResetPasswordForm.tsx
Тип: Клиентский компонент (UI и логика формы).
Назначение: Является финальным шагом в процессе сброса пароля. Компонент получает предварительно проверенный на сервере токен, предоставляет пользователю интерфейс для ввода и подтверждения нового пароля и отправляет эти данные на сервер для завершения операции.
1. Архитектурный паттерн
Классический клиентский компонент: Это 'use client' компонент, который использует хуки React (useState, useRouter) для управления состоянием, навигацией и обработкой пользовательского ввода.
Паттерн "Форма -> API Route": Как и его "брат" (ForgotPasswordForm), этот компонент следует классическому паттерну, отправляя данные через fetch на выделенный API-маршрут (/api/auth/password-reset/confirm).
UI как конечный автомат: Компонент эффективно управляет своим состоянием через isSuccess, показывая либо форму для ввода, либо сообщение об успешном изменении пароля, что обеспечивает четкий и понятный UX.
2. Безопасность и Поток Данных
Часть паттерна "Server-Side Validation First": Это ключевой аспект. Компонент является "доверяющей" стороной в более крупном паттерне. Он получает токен через props только после того, как его родительская серверная страница (reset-password/page.tsx) уже проверила валидность этого токена. Это безопасная и правильная архитектура.
Делегирование на сервер: Вся критическая логика (повторная проверка токена на предмет истечения срока или использования, хэширование нового пароля, обновление записи пользователя в БД и инвалидация токена) полностью делегирована серверному API-маршруту.
Клиентская валидация: На клиенте реализована надежная проверка: заполненность полей, минимальная длина пароля и совпадение паролей. Это улучшает UX, предоставляя мгновенную обратную связь до отправки запроса на сервер.
3. User Experience (UX)
Полный цикл обратной связи: Используется react-hot-toast для информирования пользователя на каждом этапе: загрузка, успех и любая ошибка, возвращенная сервером.
Плавный переход: После успешного изменения пароля реализован автоматический редирект на страницу входа через 3 секунды, что обеспечивает бесшовный пользовательский опыт.
Продуманный UI: Форма заблокирована во время отправки запроса, а поля ввода снабжены иконками для быстрой очистки, что соответствует общему стилю форм в проекте.
4. Связь с родительским компонентом
Этот компонент является интерактивным ядром для страницы reset-password/page.tsx. Он получает от родителя token как пропуск, подтверждающий, что пользователь имеет право находиться на этой странице, и берет на себя всю дальнейшую работу с вводом и отправкой данных. Декомпозиция выполнена образцово.
[+] src/components/auth/CodeInput.tsx
Тип: Клиентский компонент (UI-примитив / Виджет).
Назначение: Предоставляет специализированный, переиспользуемый и user-friendly интерфейс для ввода числового кода фиксированной длины (например, для двухфакторной аутентификации или верификации по email).
1. Архитектурный паттерн
Управляемый компонент (Controlled Component): Это классический управляемый компонент. Он управляет своим внутренним состоянием (массивом введенных цифр), но сообщает родительскому компоненту о любых изменениях через коллбэк onChange и о завершении ввода через onComplete. Родительский компонент, в свою очередь, решает, что делать с введенным кодом.
Компонент-примитив: Компонент является идеальным примером UI-примитива. Он полностью инкапсулирует сложную логику взаимодействия (управление фокусом, вставка из буфера) и не содержит никакой бизнес-логики. Его можно легко использовать в любой части приложения, где требуется ввод кода.
Прямое управление DOM через useRef: Компонент грамотно использует хук useRef для хранения ссылок на DOM-элементы инпутов. Это является каноничным и необходимым решением для реализации сложного UX-взаимодействия, такого как программное управление фокусом, которое невозможно реализовать через стандартное состояние React.
2. User Experience (UX) — Ключевая особенность
Этот компонент спроектирован с исключительным вниманием к пользовательскому опыту. Он реализует все ожидаемые от такого элемента функции:
Авто-фокус: После ввода цифры фокус автоматически перемещается на следующее поле.
Навигация через Backspace: Нажатие Backspace в пустом поле перемещает фокус на предыдущее поле, позволяя легко исправлять ошибки.
Обработка вставки (Paste Handling): Компонент корректно обрабатывает вставку кода из буфера обмена, автоматически распределяя цифры по ячейкам. Это значительно ускоряет и упрощает процесс для пользователя.
Валидация: Позволяет вводить только цифры, игнорируя другие символы.
3. Качество кода и Реализация
Чистота и фокус: Компонент делает одну вещь и делает ее очень хорошо. Логика четко разделена на обработчики событий (handleChange, handleKeyDown, handlePaste).
Надежное управление состоянием: Использование массива строк (string[]) для хранения кода является надежным подходом, который упрощает логику обновления отдельных цифр и навигации.
Внимание к деталям: Реализация обработчика вставки (onPaste) только для первого инпута — это умная оптимизация. Комментарий в коде, указывающий на исправление типа ref, свидетельствует о высоком уровне проработки компонента
[+] src/components/auth/VerificationModal.tsx
Тип: Клиентский компонент (Модальное окно / Диалог).
Назначение: Предоставляет полнофункциональный, переиспользуемый интерфейс для верификации email пользователя с помощью 6-значного кода. Компонент инкапсулирует весь пользовательский флоу: ввод кода, отправку на проверку, обработку ошибок и логику повторной отправки кода.
1. Архитектурный паттерн
Компонент-оркестратор: Это не просто UI-элемент, а "мини-приложение". Он импортирует и использует UI-примитив (<CodeInput>), но оборачивает его всей необходимой бизнес-логикой и управлением состоянием, оркеструя полный цикл взаимодействия с пользователем.
Паттерн "Управляемый диалог": Модальное окно является полностью управляемым извне. Его видимость контролируется родительским компонентом через пропсы isOpen и onClose. Это каноничная и правильная реализация для модальных окон в React.
Паттерн "Форма -> API Route": Как и другие интерактивные компоненты в auth-модуле, он использует классический подход с fetch-запросами к выделенным API-маршрутам (/api/auth/send-verification-code, /api/auth/verify-code).
2. Ключевая логика и Поток данных
router.refresh() — Маркер современной архитектуры Next.js: Это критически важный технический маркер. После успешной верификации кода компонент не просто закрывается, а вызывает router.refresh(). Это команда для Next.js, которая заставляет серверные компоненты текущей страницы (например, /profile/page.tsx) перезапросить свои данные и перерендериться на сервере. Затем обновленный результат "бесшовно" отправляется клиенту без полной перезагрузки страницы. Именно так родительский компонент (например, ProfileClient) узнает, что email теперь подтвержден.
Надежное управление состоянием: Компонент демонстрирует очень высокое качество управления состоянием:
Используется useEffect для сброса всех внутренних состояний (code, error, isLoading и т.д.) при закрытии модального окна. Это гарантирует, что при каждом новом открытии окно будет в "чистом" состоянии.
Реализована отдельная логика для таймера обратного отсчета, которая не блокирует основной поток.
3. User Experience (UX)
Продуманный флоу повторной отправки: Реализован 60-секундный кулдаун на кнопку повторной отправки. Это стандарт де-факто для таких интерфейсов, который предотвращает спам и дает пользователю четкую обратную связь.
Полный цикл обратной связи: Для каждого действия пользователя (проверка, повторная отправка) предусмотрены три состояния: загрузка, успех и ошибка. Это делает взаимодействие с модальным окном абсолютно предсказуемым.
Неблокирующий интерфейс: После успеха пользователю показывают сообщение и только потом, с задержкой, закрывают окно. Это позволяет пользователю понять, что произошло, прежде чем UI исчезнет.
[+] src/components/AppCore.tsx
Тип: Клиентский компонент ("Главный Оркестратор").
Назначение: Является сердцем и настоящим "каркасом" всего клиентского приложения. Этот компонент оборачивает все дочерние страницы, внедряет глобальные UI-элементы (шапка, подвал), управляет глобальными состояниями и обрабатывает побочные эффекты, затрагивающие все приложение (например, блокировка скролла, интеграция с Telegram API).
1. Архитектурная Роль: "Оркестратор" и "Менеджер Эффектов"
Компонент-Оркестратор: Это классический пример паттерна "Оркестратор". Он не выполняет много работы сам, а импортирует и координирует работу множества других, более специализированных компонентов (ConditionalHeader, Footer, SearchOverlay, NotificationManager и т.д.), выстраивая из них финальный UI.
Гидратация Глобального Состояния: Компонент выполняет ключевую задачу — "гидратацию" глобального хранилища Zustand. В useEffect он подписывается на изменения сессии из next-auth/react и синхронизирует данные пользователя с useAppStore. Это элегантное решение, которое делает состояние сессии доступным во всем приложении через единый и удобный API (useAppStore), а не через useSession напрямую.
Центральный Менеджер Побочных Эффектов (Side Effects): Компонент является единым центром для управления глобальными побочными эффектами, что является очень чистой архитектурой:
Интеграция с Telegram Mini App: При монтировании компонент конфигурирует нативное поведение Telegram-клиента (разворачивает окно, устанавливает цвет хедера, настраивает кнопку "Назад").
Глобальная Блокировка Скролла: Подписывается на состояния isSearchActive и isFloatingMenuOpen из Zustand и, в зависимости от них, применяет/снимает overflow: hidden к <html> и <body>, предотвращая прокрутку страницы под оверлеями.
Управление жестами: Отключает pinch-to-zoom на мобильных устройствах, чтобы сделать поведение приложения более "нативным".
Восстановление прокрутки: При каждой смене pathname принудительно прокручивает страницу к самому верху, имитируя поведение классических сайтов.
2. Ключевая Логика Рендеринга
Контекстно-зависимый UI: Компонент активно использует usePathname для определения текущего маршрута и кардинально меняет свою структуру на его основе.
Изоляция Auth-страниц: Реализована критически важная логика: if (isAuthPage) { return <main>{children}</main>; }. Это подтверждает наши предыдущие выводы: для страниц аутентификации AppCore рендерит только дочерний компонент, полностью отключая шапку, подвал и все остальные глобальные элементы, обеспечивая сфокусированный UX.
Владелец Главного Контейнера: Для всех остальных страниц именно этот компонент создает основной контейнер верстки (<div class="container mx-auto ...">). Это подтверждает, что другие компоненты (как catalog/page.tsx) не должны создавать свои собственные контейнеры.
3. Архитектурные Маркеры и "Code Smells"
Жесткая связь между Layout и Header (Code Smell): В компоненте присутствует стиль paddingTop: 'var(--header-height, 70px)', который применяется к <main>. Это создает неявную и хрупкую связь между этим компонентом и CSS-кодом хедера. Если высота хедера изменится в его собственном файле, верстка "сломается", и разработчику придется вспоминать, что нужно исправить это значение здесь.
Хрупкое определение типа страницы (Code Smell): Логика определения типа страницы (isHomePage, isAuthPage) основана на простых строковых операциях (pathname === '/', pathname.startsWith('/login')). Это работает, но является негибким решением. Изменение URL в будущем потребует правок в этом компоненте.
[+] src/components/ConditionalHeader.tsx
Тип: Клиентский компонент (Компонент-маршрутизатор / Switcher).
Назначение: Действует как "диспетчер" или "распределитель" для шапок сайта. Его единственная задача — анализировать текущий URL и, в зависимости от него, выбирать и рендерить один из нескольких вариантов хедера (ProductPageHeader, HybridHeader или Header).
1. Архитектурный паттерн
"Router Component" (Компонент-маршрутизатор): Это идеальный пример паттерна, при котором один компонент не содержит собственной сложной UI-логики, а служит исключительно для выбора и рендеринга одного из нескольких других компонентов. Это позволяет инкапсулировать логику выбора в одном месте, делая код чистым и легко поддерживаемым.
Централизация логики выбора: Вместо того чтобы каждая страница или layout решали, какую шапку им нужно показать, это решение централизовано здесь. Если в будущем потребуется новый тип хедера для новой страницы, изменения нужно будет вносить только в этот файл.
Мост для состояния (State Bridge): Для "стандартного" хедера (Header) этот компонент выступает в роли моста, который берет состояния и функции из глобального хранилища Zustand (isSearchActive, setSearchActive и т.д.) и передает их дальше в виде пропсов.
2. Ключевая логика рендеринга
Компонент реализует четкий и легко читаемый набор правил для выбора хедера:
Сценарий 1 (Страница товара): Если URL начинается с /product/, рендерится специализированный ProductPageHeader. Это указывает на то, что у страницы товара совершенно уникальная шапка (вероятно, с другой структурой и поведением при скролле).
Сценарий 2 (Главная страница и Профиль): Если пользователь находится на главной (/) или на странице профиля (/profile), рендерится HybridHeader. Это является ключевым архитектурным маркером, который говорит о том, что эти две, казалось бы, разные страницы, делят между собой один и тот же сложный тип хедера. Вероятно, это хедер, который меняет свой вид при прокрутке.
Сценарий 3 (По умолчанию): Для всех остальных страниц (например, /catalog, /support) рендерится самый простой, "стандартный" Header, обернутый в div с белым фоном.
3. "Code Smells" и Потенциальные проблемы
Хрупкое определение маршрутов: Как и в AppCore.tsx, логика полностью завязана на "магических строках" (pathname.startsWith('/product/'), pathname === '/profile'). Это нарушает принцип DRY (Don't Repeat Yourself), так как та же самая логика проверки маршрутов дублируется в разных частях приложения, и делает систему хрупкой к изменениям URL.
Неконсистентная стилизация обертки: Стандартный Header оборачивается в <div class="...bg-white">, в то время как ProductPageHeader и HybridHeader рендерятся без обертки. Это предполагает, что они сами несут ответственность за свой фон, что может привести к визуальной неконсистентности и усложняет управление общим стилем.
[+] src/components/Header.tsx
Тип: Клиентский компонент (Презентационный / "Глупый" компонент).
Назначение: Является стандартным, базовым хедером, который используется на большинстве страниц сайта (например, в каталоге). Он предоставляет основной UI для навигации (логотип), доступа к поиску и вызова главного меню. Его ключевая особенность — наличие двух четких визуальных состояний: "стандартный" и "поиск активен".
1. Архитектурный паттерн
"Dumb Component" (Презентационный компонент): Это образцовый пример "глупого" компонента. Он не владеет своим основным состоянием (isSearchActive, isMenuOpen). Вместо этого он получает его в виде пропсов от "умного" родительского компонента (ConditionalHeader). Его единственная задача — отрендерить UI в соответствии с этими пропсами и сообщить родителю о действиях пользователя через коллбэки (onSearchToggle, onMenuToggle). Это делает компонент легко переиспользуемым и тестируемым.
UI как конечный автомат: Визуальное представление компонента — это простая, но надежная state-машина, управляемая булевым значением isSearchActive. Это позволяет полностью изменять разметку и поведение хедера, переключаясь между двумя четко определенными состояниями.
Архитектурная неконсистентность (Code Smell): Обнаружена важная неконсистентность в управлении состоянием. Компонент получает проп onMenuToggle для управления меню, но при этом для открытия меню он вызывает setFloatingMenuOpen напрямую из глобального хранилища Zustand. Это нарушает чистоту паттерна "Dumb Component". Компонент должен либо получать все управление извне (через пропсы), либо быть полностью подключенным к стору, но не использовать смешанный подход.
2. User Experience (UX)
Плавный переход в режим поиска: При активации поиска поле ввода немедленно получает фокус (autoFocus), что позволяет пользователю сразу начать печатать без дополнительного клика. Это является лучшей практикой для UX.
Интуитивное управление: Иконки (поиск, бургер, закрытие) являются общепринятыми и интуитивно понятными для пользователя.
Незавершенный функционал: На данный момент поле ввода поиска является чисто визуальным элементом. Оно отслеживает вводимый текст во внутреннем состоянии (searchQuery), но эта информация никуда дальше не передается и никак не используется.
3. Связь с родительским компонентом
Этот компонент является "рабочей лошадкой" для ConditionalHeader. ConditionalHeader выступает в роли "умного" контейнера, который подключается к глобальному состоянию и передает Header'у все необходимые данные и функции для работы. Header же просто выполняет полученные инструкции, не зная о глобальном контексте.
[+] src/components/HybridHeader.tsx
Тип: Клиентский компонент (Компонент-обертка / "Умный" компонент).
Назначение: Является "умной" оберткой над стандартным компонентом Header. Его главная задача — превратить статичный хедер в динамический, "гибридный" UI-элемент, который реагирует на прокрутку страницы (появляется и исчезает), а также динамически сообщает остальной части приложения о своей высоте.
1. Архитектурный паттерн
"Smart Component Wrapper": Это идеальный пример "умной" обертки. Он не имеет собственного сложного UI, а вместо этого берет более простой, "глупый" компонент (Header) и наделяет его сложным поведением.
Делегирование логики в Custom Hook (Ключевое решение): Это образцовая архитектура. Вся сложная логика, связанная с отслеживанием прокрутки, вычислением translateY (для скрытия/показа) и opacity (для плавного появления), полностью инкапсулирована в кастомном хуке useHybridHeader. Сам компонент HybridHeader остается невероятно чистым и декларативным: он просто вызывает хук и применяет возвращенные им значения к стилям. Это обеспечивает максимальное разделение ответственности (Separation of Concerns).
"State Injector": Как и ConditionalHeader, этот компонент подключается к глобальному хранилищу Zustand и "впрыскивает" необходимые состояния и функции в дочерний Header через пропсы.
2. Ключевая логика и реализация
Динамический "Sticky" Header: Компонент использует position: fixed и transform: translateY(...) для создания эффекта хедера, который "уезжает" вверх за пределы экрана при прокрутке вниз и плавно "возвращается" при прокрутке вверх. Это современный и производительный способ реализации такого UX.
Глобальная CSS-переменная (Важный архитектурный маркер): useEffect в этом компоненте выполняет критически важную задачу: он измеряет собственную высоту (offsetHeight) и записывает это значение в глобальную CSS-переменную --header-height.
Зачем это нужно: Так как хедер имеет position: fixed, он "вырывается" из потока документа, и основной контент страницы (<main>) сдвигается под него. AppCore.tsx читает эту CSS-переменную и использует ее для добавления padding-top к <main>, тем самым динамически отодвигая контент вниз ровно на высоту хедера. Это элегантное и гибкое решение для связи двух независимых компонентов.
Реакция на оверлеи: Компонент передает в хук useHybridHeader флаг isOverlayOpen. Это говорит о том, что логика скрытия/показа хедера, скорее всего, отключается, когда открыт поиск или плавающее меню, чтобы хедер не исчезал в тот момент, когда пользователь с ним взаимодействует. Это продуманное UX-решение.
3. "Code Smells" / Архитектурные проблемы
"Протекающая" логика (Leaky Abstraction): Компонент вычисляет opacity и передает его дальше в дочерний Header через проп contentOpacity. Это является "протекающей абстракцией". Поведение, связанное с прозрачностью, является ответственностью HybridHeader, и он должен применять его к себе или к своей обертке, а не заставлять дочерний компонент знать о деталях этой реализации. Это создает ненужную связанность (coupling).
[+] src/components/hooks/useHybridHeader.ts
Тип: Кастомный хук React (Custom Hook).
Назначение: Является "движком" и "мозгом" для HybridHeader. Этот хук инкапсулирует всю сложную, низкоуровневую логику для создания плавного, производительного и отзывчивого эффекта хедера, который прячется при прокрутке.
1. Архитектурный паттерн и Ключевые решения
"Логика в хуке, а не в компоненте": Это образцовая реализация принципа кастомных хуков. Вся сложная, императивная логика (подписка на события, работа с ref, таймеры, вычисления) полностью изолирована здесь. Компонент, который его использует (HybridHeader), остается чисто декларативным — он просто получает результат (translateY, opacity) и применяет его.
Сложная State Machine: Хук представляет собой сложный конечный автомат, который отслеживает не только позицию скролла, но и его направление, скорость (неявно через dy), а также состояние взаимодействия пользователя (касание экрана).
Косвенное управление DOM: Хук не изменяет DOM напрямую. Он читает из DOM (headerRef.current.offsetHeight) и возвращает значения состояния (translateY, opacity). Компонент React затем использует эти значения для обновления стилей, позволяя React эффективно управлять рендерингом.
2. Управление состоянием и жизненным циклом (Ключевая особенность)
Хук демонстрирует мастерское использование useState и useRef для разных задач:
useState (translateY, opacity): Используется для значений, изменение которых должно вызывать перерисовку родительского компонента. Это именно то, что нужно для обновления стилей.
useRef (lastScrollY, currentTranslate, ticking, isTouching и т.д.): Используется для хранения внутренних данных, которые должны сохраняться между рендерами, но изменение которых не должно вызывать перерисовку. Использование useState для lastScrollY привело бы к катастрофической производительности, так как компонент перерисовывался бы на каждый пиксель скролла. Это разделение — признак высокопроизводительного, хорошо спроектированного хука.
useEffect: Основной useEffect действует как конструктор и деструктор. Он запускается, когда isOverlayOpen меняется, и корректно настраивает и, что важнее, очищает все слушатели событий и таймеры, предотвращая утечки памяти.
3. Производительность и User Experience (UX)
Этот хук является мастер-классом по созданию плавного UI:
requestAnimationFrame (Паттерн "ticking"): Это золотой стандарт для оптимизации обработчиков скролла. Вместо того чтобы вызывать setTranslateY и setOpacity на каждое событие скролла (что может происходить десятки раз в секунду), все вычисления и обновления состояния группируются и выполняются один раз прямо перед следующей отрисовкой кадра браузером. Это предотвращает "layout thrashing" и обеспечивает максимально плавную анимацию.
Пассивные слушатели (passive: true): При добавлении слушателя скролла используется опция { passive: true }. Это сообщает браузеру, что обработчик не будет отменять скролл, позволяя браузеру оптимизировать его и сделать прокрутку более отзывчивой, особенно на мобильных устройствах.
"Прилипание к краям" (snapToEdge): Это ключевая UX-фича. Когда пользователь прекращает прокрутку, хук не оставляет хедер в полускрытом состоянии. Он вычисляет, скрыта ли большая часть хедера (snapThreshold), и плавно "доводит" его до полностью скрытого или полностью видимого состояния.
Учет касаний (onTouchStart / onTouchEnd): Логика "прилипания" становится еще умнее. Она не срабатывает, пока палец пользователя находится на экране (isTouching.current). "Прилипание" происходит только после того, как пользователь отпускает экран, что делает взаимодействие интуитивно понятным.
Уважение к настройкам пользователя (prefers-reduced-motion): Хук проверяет системные настройки доступности и отключает плавную анимацию для пользователей, которые предпочитают уменьшенное движение. Это признак высококачественной и инклюзивной разработки.
[+] src/components/FloatingMenuOverlay/index.tsx  Тип: Клиентский компонент (Компонент-оркестратор / Composite View).  Назначение: Является главным компонентом для "плавающего" оверлей-меню, которое открывается по клику на "бургер". Его основная задача — собрать воедино множество более мелких, специализированных компонентов (MenuHeader, AuthenticatedView, CartSummary и т.д.), чтобы сформировать полнофункциональную навигационную панель.  1. Архитектурный паттерн "Component Orchestrator" (Компонент-оркестратор): Это классический оркестратор. Он не содержит сложной верстки, а его главная роль — импортировать, компоновать и передавать данные в дочерние компоненты, которые отвечают за конкретные блоки меню.  "Controlled Component" (Управляемый компонент): Его видимость полностью контролируется извне через пропсы isOpen и onClose. Это правильная и гибкая архитектура, позволяющая родительскому компоненту (в конечном счете, AppCore через Zustand) решать, когда меню должно быть показано или скрыто.  State-Driven UI Branching (Ветвление UI на основе состояния): Ключевая логика компонента — это условный рендеринг: isAuthenticated ? <AuthenticatedView user={user} ... /> : <GuestView ... />. Это мощный паттерн, который кардинально меняет часть интерфейса в зависимости от состояния аутентификации пользователя, показывая либо персонализированный блок, либо призыв к действию для гостя.  2. Ключевая логика и реализация Модульная структура: Компонент является вершиной целого модуля (/FloatingMenuOverlay). Он демонстрирует отличную декомпозицию: каждый логический блок меню (шапка, блок пользователя, корзина, навигация, футер) вынесен в свой собственный, сфокусированный компонент. Это делает код чрезвычайно читаемым и легким для поддержки.  Управление дочерними модальными окнами: Компонент владеет состоянием isModalOpen для VerificationModal. Он передает функцию для открытия этого окна (openVerificationModal) в дочерний компонент AuthenticatedView. Это правильный паттерн, где родитель управляет состоянием, а дочерний компонент инициирует его изменение.  Передача коллбэков (Prop Drilling): Коллбэк onClose передается "вглубь" дерева компонентов (MenuHeader, AuthenticatedView, GuestView и т.д.). Для такого инкапсулированного модуля это является приемлемой практикой "prop drilling".  3. "Code Smells" / Архитектурные неконсистентности Критическая неконсистентность (Потенциальный баг): В коде присутствует прямое противоречие. Комментарий гласит // Email больше не нужен как пропс, однако при рендеринге <VerificationModal> ему явно передается проп email={user?.email}. Это указывает на незавершенный рефакторинг и является серьезным техническим долгом, который может привести к ошибкам.  "Магическое число" для z-index: Используется жестко закодированный z-[100]. Это еще одно подтверждение проблемы, выявленной ранее: z-индексы не управляются централизованно, что делает UI хрупким.
[+] src/components/FloatingMenuOverlay/MenuHeader.tsx
Тип: Клиентский компонент (Composite UI Component).
Назначение: Является шапкой для оверлей-меню. Его задача — предоставить пользователю знакомые элементы навигации (логотип), возможность закрыть текущее меню и, что важно, перейти в режим глобального поиска.
1. Архитектурный паттерн
Смешанный "Smart/Dumb" компонент: Компонент демонстрирует смешанный подход. Он является "глупым" в том, что получает команду на закрытие (onClose) от родителя. Однако он является "умным", так как напрямую взаимодействует с глобальным хранилищем Zustand (useAppStore), чтобы активировать глобальный поиск (setSearchActive).
Внутреннее управление состоянием: Компонент имеет собственное локальное состояние isSearchModeActive, которое должно управлять его внутренним UI, переключая его в режим поиска.
